import { GithubRepositoryData, GithubRepositoryResponse } from './models';

export const MOCK_DATA: { data: GithubRepositoryResponse } = {
  data: {
    repository: {
      issues: {
        edges: [
          {
            node: {
              id: 'I_kwDOKvyTu856sTyE',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Rust Course ü¶Ä] Rust Practices with Rustlings (01-04)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: '2023-12-28T13:26:12Z',
              body: '<img width="1146" alt="Screenshot 2023-12-28 at 20 20 08" src="https://github.com/lowlevelers/lowlevelers.com/assets/56880684/d4935570-6f30-43c4-88c7-7736cc7ebf31">\r\n\r\n## Description\r\n\r\nSolving exercises in Rustlings repository and delivers your way of thinking + solutions to the community members. To get assigned, please mention your name in the comment section below with the expected time to finish the issue. \r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn Rust from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T04:02:42Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T04:47:19Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T05:56:31Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T06:43:13Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 1,
                    },
                    publishedAt: '2024-01-03T06:46:25Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T09:41:06Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T14:09:21Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-04T03:07:49Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-04T15:59:15Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-05T03:13:35Z',
                  },
                ],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [
                  {
                    login: 'henchiyb',
                  },
                ],
                pageInfo: {
                  startCursor: 'MQ',
                  endCursor: 'MQ',
                  hasNextPage: false,
                },
                totalCount: 1,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856sVyo',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Rust Course ü¶Ä] Rust Practices with Rustlings (05-09)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '\r\n<img width="1142" alt="Screenshot 2023-12-28 at 20 28 02" src="https://github.com/lowlevelers/lowlevelers.com/assets/56880684/f554b6ca-511c-4536-84f4-bcdf7b11be26">\r\n\r\n## Description\r\n\r\nSolving exercises in Rustlings repository and delivers your way of thinking + solutions to the community members. To get assigned, please mention your name in the comment section below with the expected time to finish the issue. \r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn Rust from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9',
              comments: {
                nodes: [
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-05T03:52:27Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-05T04:25:12Z',
                  },
                ],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [
                  {
                    login: 'henchiyb',
                  },
                ],
                pageInfo: {
                  startCursor: 'MQ',
                  endCursor: 'MQ',
                  hasNextPage: false,
                },
                totalCount: 1,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856sWPc',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Rust Course ü¶Ä] Rust Practices with Rustlings (10-15)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '<img width="1146" alt="Screenshot 2023-12-28 at 20 29 48" src="https://github.com/lowlevelers/lowlevelers.com/assets/56880684/4946e830-04bb-4baf-b570-828f5f636375">\r\n\r\n## Description\r\n\r\nSolving exercises in Rustlings repository and delivers your way of thinking + solutions to the community members. To get assigned, please mention your name in the comment section below with the expected time to finish the issue. \r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn Rust from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856sWwg',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Rust Course ü¶Ä] Rust Practices with Rustlings (16-19)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '<img width="1143" alt="Screenshot 2023-12-28 at 20 31 55" src="https://github.com/lowlevelers/lowlevelers.com/assets/56880684/3035e598-cfd7-4854-8281-84280b7a6a96">\r\n\r\n## Description\r\n\r\nSolving exercises in Rustlings repository and delivers your way of thinking + solutions to the community members. To get assigned, please mention your name in the comment section below with the expected time to finish the issue. \r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn Rust from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856sW63',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Rust Course ü¶Ä] Rust Practices with Rustlings (20-23)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '<img width="1138" alt="Screenshot 2023-12-28 at 20 32 50" src="https://github.com/lowlevelers/lowlevelers.com/assets/56880684/3df82671-f449-47bc-b35d-ca376e7883e9">\r\n\r\n## Description\r\n\r\nSolving exercises in Rustlings repository and delivers your way of thinking + solutions to the community members. To get assigned, please mention your name in the comment section below with the expected time to finish the issue. \r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn Rust from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856sYgf',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Prepare for PBA üìô] pba_book: blockchain from scratch (c1_state_machine)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 4,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'one-contributor-only',
                    color: 'F6A625',
                    createdAt: '2023-12-28T13:26:37Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '### Discussed in https://github.com/orgs/lowlevelers/discussions/7\r\n\r\n<div type=\'discussions-op-text\'>\r\n\r\n<sup>Originally posted by **chungquantin** December 27, 2023</sup>\r\n## Description\r\n\r\nRequired reading: https://polkadot-blockchain-academy.github.io/pba-book/blockchain-contracts/services-as-state-machines/page.html\r\n\r\nWhat\'s intriguing is that the majority, if not all, of the systems we are concerned with can be conceptualized as state machines. A state machine isn\'t a tangible, touchable machine in the physical sense; rather, it\'s a model consisting of a defined set of states and a set of rules governing the transitions between those states. In visualizing this, imagine my state machine initiating from state one, and then an external trigger, perhaps akin to a specific action or transaction in blockchain terms, propels it into state two. \r\n\r\nTherefore, our objective with the blockchain is to meticulously record the entire sequence of these transitions. By maintaining a comprehensive history of all transitions, we gain the ability to discern our current state in the system.\r\n\r\nBelow are the solutions for the exercise `c1_state_machine` in `pba_book`. Please use this as a reference if you get any blockers. I still recommend working through the problem set on your own so you can fully understand the concept of the state machine.\r\n\r\n## Other learning materials\r\n- Substrate state machine implementation (sp_state_machine): [sp-state-machine](https://docs.rs/sp-state-machine/latest/src/sp_state_machine/lib.rs.html#18-1963:~:text=pub%20struct%20StateMachine,Out%3E%2C%0A%09%09context%3A%20CallContext%2C%0A%09%7D)\r\n- Rust state machine (Substrate minimal version): https://github.com/shawntabrizi/rust-state-machine\r\n\r\n## Answer\r\n### p1_switches.rs\r\n```rust\r\n//! We begin our hands on exploration of state machines with two very simple examples.\r\n//! In these examples, we use actually switch boards as the state machine. The state is,\r\n//! well, just the state of the switches.\r\n\r\nuse super::StateMachine;\r\n\r\n/// This state machine models a single light switch.\r\n/// The internal state, a bool, represents whether the switch is on or not.\r\npub struct LightSwitch;\r\n\r\n/// We model this simple system as a state machine with a single transition - toggling the switch\r\n/// Because there is only a single kind of transition, we can use a unit struct.\r\nimpl StateMachine for LightSwitch {\r\n\ttype State = bool;\r\n\ttype Transition = ();\r\n\r\n\tfn next_state(starting_state: &bool, t: &()) -> bool {\r\n\t\t!starting_state\r\n\t}\r\n}\r\n\r\n/// This second  state machine models two light switches with one weird property.\r\n/// Whenever switch one is turned off, switch two also goes off.\r\npub struct WeirdSwitchMachine;\r\n\r\n/// The state is now two switches instead of one so we use a struct.\r\n#[derive(PartialEq, Eq, Clone, Debug)]\r\npub struct TwoSwitches {\r\n\tfirst_switch: bool,\r\n\tsecond_switch: bool,\r\n}\r\n\r\n/// Now there are two switches so we need a proper type for the transition.\r\npub enum Toggle {\r\n\tFirstSwitch,\r\n\tSecondSwitch,\r\n}\r\n\r\n/// We model this system as a state machine with two possible transitions\r\nimpl StateMachine for WeirdSwitchMachine {\r\n\ttype State = TwoSwitches;\r\n\ttype Transition = Toggle;\r\n\r\n\tfn next_state(starting_state: &TwoSwitches, t: &Toggle) -> TwoSwitches {\r\n\t\tlet mut next_state = starting_state.clone();\r\n\t\tmatch t {\r\n\t\t\tToggle::FirstSwitch => {\r\n\t\t\t\tif starting_state.first_switch {\r\n\t\t\t\t\tnext_state.second_switch = false;\r\n\t\t\t\t}\r\n\t\t\t\tnext_state.first_switch = !starting_state.first_switch;\r\n\t\t\t},\r\n\t\t\tToggle::SecondSwitch => next_state.second_switch = !next_state.second_switch,\r\n\t\t}\r\n\t\tnext_state\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn sm_1_light_switch_toggles_off() {\r\n\tassert!(!LightSwitch::next_state(&true, &()));\r\n}\r\n\r\n#[test]\r\nfn sm_1_light_switch_toggles_on() {\r\n\tassert!(LightSwitch::next_state(&false, &()));\r\n}\r\n\r\n#[test]\r\nfn sm_1_two_switches_first_goes_on() {\r\n\tlet state = TwoSwitches { first_switch: false, second_switch: false };\r\n\r\n\tassert_eq!(\r\n\t\tWeirdSwitchMachine::next_state(&state, &Toggle::FirstSwitch),\r\n\t\tTwoSwitches { first_switch: true, second_switch: false }\r\n\t);\r\n}\r\n\r\n#[test]\r\nfn sm_1_two_switches_first_goes_off_second_was_on() {\r\n\t// This is the special case. We have to make sure the second one goes off with it.\r\n\tlet state = TwoSwitches { first_switch: true, second_switch: true };\r\n\r\n\tassert_eq!(\r\n\t\tWeirdSwitchMachine::next_state(&state, &Toggle::FirstSwitch),\r\n\t\tTwoSwitches { first_switch: false, second_switch: false }\r\n\t);\r\n}\r\n\r\n#[test]\r\nfn sm_1_two_switches_first_goes_off_second_was_off() {\r\n\t// This is adjacent to the special case. We have to make sure the second one stays off.\r\n\tlet state = TwoSwitches { first_switch: true, second_switch: false };\r\n\r\n\tassert_eq!(\r\n\t\tWeirdSwitchMachine::next_state(&state, &Toggle::FirstSwitch),\r\n\t\tTwoSwitches { first_switch: false, second_switch: false }\r\n\t);\r\n}\r\n\r\n#[test]\r\nfn sm_1_two_switches_second_goes_on() {\r\n\tlet state = TwoSwitches { first_switch: false, second_switch: false };\r\n\r\n\tassert_eq!(\r\n\t\tWeirdSwitchMachine::next_state(&state, &Toggle::SecondSwitch),\r\n\t\tTwoSwitches { first_switch: false, second_switch: true }\r\n\t);\r\n}\r\n\r\n#[test]\r\nfn sm_1_two_switches_second_goes_off() {\r\n\tlet state = TwoSwitches { first_switch: true, second_switch: true };\r\n\r\n\tassert_eq!(\r\n\t\tWeirdSwitchMachine::next_state(&state, &Toggle::SecondSwitch),\r\n\t\tTwoSwitches { first_switch: true, second_switch: false }\r\n\t);\r\n}\r\n\r\n```\r\n\r\n## p2_laundry_machine.rs\r\n```rust\r\n//! When you wear clothes they get dirty. When you wash them they get wet. When you dry them,\r\n//! they\'re ready to be worn again. Or course washing and wearing clothes takes its toll on the\r\n//! clothes, and eventually they get tattered.\r\n\r\nuse super::StateMachine;\r\n\r\n/// This state machine models the typical life cycle of clothes as they make their way through the\r\n/// laundry cycle several times before ultimately becoming tattered.\r\npub struct ClothesMachine;\r\n\r\n/// Models a piece of clothing throughout its lifecycle.\r\n#[derive(PartialEq, Eq, Debug)]\r\npub enum ClothesState {\r\n\t/// Clean clothes ready to be worn. With some given life left.\r\n\tClean(u64),\r\n\t/// Dirty clothes. With some given life left.\r\n\tDirty(u64),\r\n\t/// Wet clothes. With some given life left. The clothes are assumed to be wet because\r\n\t/// they were just washed. And washing clothes is the only modeled way to get them wet.\r\n\tWet(u64),\r\n\t/// Tattered clothes beyond their useful life. These clothes will always be tattered no matter\r\n\t/// what is done with them.\r\n\tTattered,\r\n}\r\n\r\n/// Something you can do with clothes\r\npub enum ClothesAction {\r\n\t/// Wearing clothes decreases their life by 1 and makes them dirty.\r\n\tWear,\r\n\t/// Washing clothes decreases their life by 1, and makes them wet.\r\n\tWash,\r\n\t/// This operation models a tumble drier. Drying clothes decreases their life by 1.\r\n\t/// If the clothes were clean or wet to begin with they will be clean after drying.\r\n\t/// If they were dirty to begin with, they will still be dirty after drying.\r\n\tDry,\r\n}\r\n\r\nimpl StateMachine for ClothesMachine {\r\n\ttype State = ClothesState;\r\n\ttype Transition = ClothesAction;\r\n\r\n\tfn next_state(starting_state: &ClothesState, t: &ClothesAction) -> ClothesState {\r\n\t\tlet given_life = match starting_state {\r\n\t\t\tClothesState::Clean(life) => life,\r\n\t\t\tClothesState::Dirty(life) => life,\r\n\t\t\tClothesState::Wet(life) => life,\r\n\t\t\tClothesState::Tattered => return ClothesState::Tattered,\r\n\t\t};\r\n\t\tlet life_left = given_life - 1;\r\n\r\n\t\tif life_left == 0 {\r\n\t\t\treturn ClothesState::Tattered;\r\n\t\t}\r\n\r\n\t\tmatch t {\r\n\t\t\tClothesAction::Wash => return ClothesState::Wet(life_left),\r\n\t\t\tClothesAction::Dry => {\r\n\t\t\t\tlet dummy_dirty = ClothesState::Dirty(*given_life);\r\n\t\t\t\tif *starting_state == dummy_dirty {\r\n\t\t\t\t\treturn ClothesState::Dirty(life_left);\r\n\t\t\t\t}\r\n\t\t\t\treturn ClothesState::Clean(life_left);\r\n\t\t\t},\r\n\t\t\tClothesAction::Wear => return ClothesState::Dirty(life_left),\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_clean_clothes() {\r\n\tlet start = ClothesState::Clean(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Dirty(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_dirty_clothes() {\r\n\tlet start = ClothesState::Dirty(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Dirty(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_wet_clothes() {\r\n\tlet start = ClothesState::Wet(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Dirty(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_tattered_clothes() {\r\n\tlet start = ClothesState::Tattered;\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_clean_until_tattered() {\r\n\tlet start = ClothesState::Clean(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_wet_until_tattered() {\r\n\tlet start = ClothesState::Wet(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wear_dirty_until_tattered() {\r\n\tlet start = ClothesState::Dirty(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wear);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_clean_clothes() {\r\n\tlet start = ClothesState::Clean(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Wet(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_dirty_clothes() {\r\n\tlet start = ClothesState::Dirty(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Wet(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_wet_clothes() {\r\n\tlet start = ClothesState::Wet(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Wet(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_tattered_clothes() {\r\n\tlet start = ClothesState::Tattered;\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_clean_until_tattered() {\r\n\tlet start = ClothesState::Clean(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_wet_until_tattered() {\r\n\tlet start = ClothesState::Wet(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_wash_dirty_until_tattered() {\r\n\tlet start = ClothesState::Dirty(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Wash);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_clean_clothes() {\r\n\tlet start = ClothesState::Clean(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Clean(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_dirty_clothes() {\r\n\tlet start = ClothesState::Dirty(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Dirty(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_wet_clothes() {\r\n\tlet start = ClothesState::Wet(4);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Clean(3);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_tattered_clothes() {\r\n\tlet start = ClothesState::Tattered;\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_clean_until_tattered() {\r\n\tlet start = ClothesState::Clean(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_cwet_until_tattered() {\r\n\tlet start = ClothesState::Wet(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_2_dry_dirty_until_tattered() {\r\n\tlet start = ClothesState::Dirty(1);\r\n\tlet end = ClothesMachine::next_state(&start, &ClothesAction::Dry);\r\n\tlet expected = ClothesState::Tattered;\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n```\r\n## p3_atm.rs\r\n```rust\r\n//! The automated teller machine gives you cash after you swipe your card and enter your pin.\r\n//! The atm may fail to give you cash if it is empty or you haven\'t swiped your card, or you have\r\n//! entered the wrong pin.\r\n\r\nuse super::StateMachine;\r\n\r\n/// The keys on the ATM keypad\r\n#[derive(Hash, Debug, PartialEq, Eq, Clone)]\r\npub enum Key {\r\n\tOne,\r\n\tTwo,\r\n\tThree,\r\n\tFour,\r\n\tEnter,\r\n}\r\n\r\n/// Something you can do to the ATM\r\npub enum Action {\r\n\t/// Swipe your card at the ATM. The attached value is the hash of the pin\r\n\t/// that should be keyed in on the keypad next.\r\n\tSwipeCard(u64),\r\n\t/// Press a key on the keypad\r\n\tPressKey(Key),\r\n}\r\n\r\n/// The various states of authentication possible with the ATM\r\n#[derive(Debug, PartialEq, Eq, Clone)]\r\nenum Auth {\r\n\t/// No session has begun yet. Waiting for the user to swipe their card\r\n\tWaiting,\r\n\t/// The user has swiped their card, providing the enclosed PIN hash.\r\n\t/// Waiting for the user to key in their pin\r\n\tAuthenticating(u64),\r\n\t/// The user has authenticated. Waiting for them to key in the amount\r\n\t/// of cash to withdraw\r\n\tAuthenticated,\r\n}\r\n\r\n/// The ATM. When a card is swiped, the ATM learns the correct pin\'s hash.\r\n/// It waits for you to key in your pin. You can press as many numeric keys as\r\n/// you like followed by enter. If the pin is incorrect, your card is returned\r\n/// and the ATM automatically goes back to the main menu. If your pin is correct,\r\n/// the ATM waits for you to key in an amount of money to withdraw. Withdraws\r\n/// are bounded only by the cash in the machine (there is no account balance).\r\n#[derive(Debug, PartialEq, Eq, Clone)]\r\npub struct Atm {\r\n\t/// How much money is in the ATM\r\n\tcash_inside: u64,\r\n\t/// The machine\'s authentication status.\r\n\texpected_pin_hash: Auth,\r\n\t/// All the keys that have been pressed since the last `Enter`\r\n\tkeystroke_register: Vec<Key>,\r\n}\r\n\r\nimpl StateMachine for Atm {\r\n\t// Notice that we are using the same type for the state as we are using for the machine this\r\n\t// time.\r\n\ttype State = Self;\r\n\ttype Transition = Action;\r\n\r\n\tfn next_state(starting_state: &Self::State, t: &Self::Transition) -> Self::State {\r\n\t\tlet atm = starting_state;\r\n\t\tlet mut updated_atm = starting_state.clone();\r\n\r\n\t\tlet key_to_num = move |key: Key| match key {\r\n\t\t\tKey::One => 1,\r\n\t\t\tKey::Two => 2,\r\n\t\t\tKey::Three => 3,\r\n\t\t\tKey::Four => 4,\r\n\t\t\t_ => panic!("no valid key num found"),\r\n\t\t};\r\n\r\n\t\tmatch t {\r\n\t\t\tAction::SwipeCard(value) => {\r\n\t\t\t\tupdated_atm.expected_pin_hash = Auth::Authenticating(*value);\r\n\t\t\t},\r\n\t\t\tAction::PressKey(key) => {\r\n\t\t\t\tif *key == Key::Enter {\r\n\t\t\t\t\tlet provided_pin_hash = crate::hash(&atm.keystroke_register);\r\n\t\t\t\t\tmatch atm.expected_pin_hash {\r\n\t\t\t\t\t\tAuth::Authenticated => {\r\n\t\t\t\t\t\t\tlet mut withdraw_amount = 0;\r\n\t\t\t\t\t\t\tatm.keystroke_register.iter().enumerate().for_each(|(i, k)| {\r\n\t\t\t\t\t\t\t\twithdraw_amount += key_to_num(k.clone())\r\n\t\t\t\t\t\t\t\t\t* 10_u64.pow((atm.keystroke_register.len() - i) as u32 - 1);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tif withdraw_amount <= atm.cash_inside {\r\n\t\t\t\t\t\t\t\tupdated_atm.cash_inside -= withdraw_amount;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tupdated_atm.expected_pin_hash = Auth::Waiting;\r\n\t\t\t\t\t\t\tupdated_atm.keystroke_register = vec![];\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tAuth::Authenticating(value) => {\r\n\t\t\t\t\t\t\tif provided_pin_hash == value {\r\n\t\t\t\t\t\t\t\tupdated_atm.expected_pin_hash = Auth::Authenticated;\r\n\t\t\t\t\t\t\t\tupdated_atm.keystroke_register = vec![];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tupdated_atm.expected_pin_hash = Auth::Waiting;\r\n\t\t\t\t\t\t\t\tupdated_atm.keystroke_register = vec![];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t_ => unimplemented!(),\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if atm.expected_pin_hash != Auth::Waiting {\r\n\t\t\t\t\t// add keystroke\r\n\t\t\t\t\tupdated_atm.keystroke_register.push(key.clone());\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t}\r\n\t\treturn updated_atm;\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn sm_3_simple_swipe_card() {\r\n\tlet start =\r\n\t\tAtm { cash_inside: 10, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\tlet end = Atm::next_state(&start, &Action::SwipeCard(1234));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_swipe_card_again_part_way_through() {\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::SwipeCard(1234));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: vec![Key::One, Key::Three],\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::SwipeCard(1234));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: vec![Key::One, Key::Three],\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_press_key_before_card_swipe() {\r\n\tlet start =\r\n\t\tAtm { cash_inside: 10, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::One));\r\n\tlet expected =\r\n\t\tAtm { cash_inside: 10, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_enter_single_digit_of_pin() {\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::One));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: vec![Key::One],\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: vec![Key::One],\r\n\t};\r\n\tlet end1 = Atm::next_state(&start, &Action::PressKey(Key::Two));\r\n\tlet expected1 = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(1234),\r\n\t\tkeystroke_register: vec![Key::One, Key::Two],\r\n\t};\r\n\r\n\tassert_eq!(end1, expected1);\r\n}\r\n\r\n#[test]\r\nfn sm_3_enter_wrong_pin() {\r\n\t// Create hash of pin\r\n\tlet pin = vec![Key::One, Key::Two, Key::Three, Key::Four];\r\n\tlet pin_hash = crate::hash(&pin);\r\n\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(pin_hash),\r\n\t\tkeystroke_register: vec![Key::Three, Key::Three, Key::Three, Key::Three],\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::Enter));\r\n\tlet expected =\r\n\t\tAtm { cash_inside: 10, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_enter_correct_pin() {\r\n\t// Create hash of pin\r\n\tlet pin = vec![Key::One, Key::Two, Key::Three, Key::Four];\r\n\tlet pin_hash = crate::hash(&pin);\r\n\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticating(pin_hash),\r\n\t\tkeystroke_register: vec![Key::One, Key::Two, Key::Three, Key::Four],\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::Enter));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_enter_single_digit_of_withdraw_amount() {\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: Vec::new(),\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::One));\r\n\tlet expected = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: vec![Key::One],\r\n\t};\r\n\r\n\tassert_eq!(end, expected);\r\n\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: vec![Key::One],\r\n\t};\r\n\tlet end1 = Atm::next_state(&start, &Action::PressKey(Key::Four));\r\n\tlet expected1 = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: vec![Key::One, Key::Four],\r\n\t};\r\n\r\n\tassert_eq!(end1, expected1);\r\n}\r\n\r\n#[test]\r\nfn sm_3_try_to_withdraw_too_much() {\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: vec![Key::One, Key::Four],\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::Enter));\r\n\tlet expected =\r\n\t\tAtm { cash_inside: 10, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_3_withdraw_acceptable_amount() {\r\n\tlet start = Atm {\r\n\t\tcash_inside: 10,\r\n\t\texpected_pin_hash: Auth::Authenticated,\r\n\t\tkeystroke_register: vec![Key::One],\r\n\t};\r\n\tlet end = Atm::next_state(&start, &Action::PressKey(Key::Enter));\r\n\tlet expected =\r\n\t\tAtm { cash_inside: 9, expected_pin_hash: Auth::Waiting, keystroke_register: Vec::new() };\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n```\r\n## p4_accounted_currency.rs\r\n```rust\r\n//! The state machines we have written so far model individual devices that are typically used\r\n//! by a single user at a time. State machines can also model multi user systems. Blockchains\r\n//! strive to provide reliable public infrastructure. And the public is very much multiple users.\r\n//!\r\n//! In this module and the next we explore two common techniques at modeling multi-user state\r\n//! machines. In this module we explore accounts, and in the next we explore UTXOs.\r\n//!\r\n//! In this module we design a state machine that tracks the currency balances of several users.\r\n//! Each user is associated with an account balance and users are able to send money to other users.\r\n\r\nuse super::{StateMachine, User};\r\nuse std::collections::HashMap;\r\n\r\n/// This state machine models a multi-user currency system. It tracks the balance of each\r\n/// user and allows users to send funds to one another.\r\npub struct AccountedCurrency;\r\n\r\nconst MINIMUM_EXISTENTIAL_BALANCE: u64 = 1;\r\n\r\n/// The main balances mapping.\r\n///\r\n/// Each entry maps a user id to their corresponding balance.\r\n/// There exists an existential deposit of at least 1. That is\r\n/// to say that an account gets removed from the map entirely\r\n/// when its balance falls back to 0.\r\ntype Balances = HashMap<User, u64>;\r\n\r\n/// The state transitions that users can make in an accounted currency system\r\npub enum AccountingTransaction {\r\n\t/// Create some new money for the given minter in the given amount\r\n\tMint { minter: User, amount: u64 },\r\n\t/// Destroy some money from the given account in the given amount\r\n\t/// If the burn amount exceeds the account balance, burn the entire\r\n\t/// amount and remove the account from storage\r\n\tBurn { burner: User, amount: u64 },\r\n\t/// Send some tokens from one account to another\r\n\tTransfer { sender: User, receiver: User, amount: u64 },\r\n}\r\n\r\nimpl AccountedCurrency {\r\n\tfn mint(updated_balances: &mut Balances, minter: &User, amount: &u64) {\r\n\t\tlet get_minter_balance = updated_balances.get_mut(minter);\r\n\t\tmatch get_minter_balance {\r\n\t\t\tSome(balance) => {\r\n\t\t\t\t*balance = balance.saturating_add(*amount);\r\n\t\t\t},\r\n\t\t\tNone => {\r\n\t\t\t\tif *amount >= MINIMUM_EXISTENTIAL_BALANCE {\r\n\t\t\t\t\tupdated_balances.insert(*minter, *amount);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t}\r\n\t}\r\n\r\n\tfn burn(updated_balances: &mut Balances, burner: &User, amount: &u64) {\r\n\t\tlet get_burner_balance = updated_balances.get_mut(burner);\r\n\t\tif let Some(cur_balance) = get_burner_balance {\r\n\t\t\t*cur_balance = cur_balance.saturating_sub(*amount);\r\n\t\t\tif *cur_balance < MINIMUM_EXISTENTIAL_BALANCE {\r\n\t\t\t\tupdated_balances.remove(burner);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/// We model this system as a state machine with three possible transitions\r\nimpl StateMachine for AccountedCurrency {\r\n\ttype State = Balances;\r\n\ttype Transition = AccountingTransaction;\r\n\r\n\tfn next_state(starting_state: &Balances, t: &AccountingTransaction) -> Balances {\r\n\t\tlet mut updated_balances = starting_state.clone();\r\n\t\tmatch t {\r\n\t\t\tAccountingTransaction::Mint { minter, amount } => {\r\n\t\t\t\tSelf::mint(&mut updated_balances, minter, amount);\r\n\t\t\t},\r\n\t\t\tAccountingTransaction::Burn { burner, amount } => {\r\n\t\t\t\tSelf::burn(&mut updated_balances, burner, amount);\r\n\t\t\t},\r\n\t\t\tAccountingTransaction::Transfer { sender, receiver, amount } => {\r\n\t\t\t\tlet sender_balance = starting_state.get(sender).unwrap_or_else(|| &0);\r\n\t\t\t\tif sender_balance >= amount {\r\n\t\t\t\t\tSelf::burn(&mut updated_balances, sender, amount);\r\n\t\t\t\t\tSelf::mint(&mut updated_balances, receiver, amount);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t}\r\n\t\treturn updated_balances;\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn sm_4_mint_creates_account() {\r\n\tlet start = HashMap::new();\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Mint { minter: User::Alice, amount: 100 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_mint_creates_second_account() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Mint { minter: User::Bob, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_mint_increases_balance() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Mint { minter: User::Alice, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 150)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_empty_mint() {\r\n\tlet start = HashMap::new();\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Mint { minter: User::Alice, amount: 0 },\r\n\t);\r\n\tlet expected = HashMap::new();\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_simple_burn() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Alice, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_burn_no_existential_deposit_left() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Bob, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_non_registered_burner() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Bob, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_burn_more_than_balance() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end2 = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Bob, amount: 100 },\r\n\t);\r\n\tlet expected2 = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end2, expected2);\r\n}\r\n\r\n#[test]\r\nfn sm_4_empty_burn() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Alice, amount: 0 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_burner_does_not_exist() {\r\n\tlet start = HashMap::from([(User::Alice, 100)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Burn { burner: User::Bob, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_simple_transfer() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Alice, receiver: User::Bob, amount: 10 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 90), (User::Bob, 60)]);\r\n\r\n\tassert_eq!(end, expected);\r\n\r\n\tlet start = HashMap::from([(User::Alice, 90), (User::Bob, 60)]);\r\n\tlet end1 = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Bob, receiver: User::Alice, amount: 50 },\r\n\t);\r\n\tlet expected1 = HashMap::from([(User::Alice, 140), (User::Bob, 10)]);\r\n\r\n\tassert_eq!(end1, expected1);\r\n}\r\n\r\n#[test]\r\nfn sm_4_send_to_same_user() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Bob, receiver: User::Bob, amount: 10 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_insufficient_balance_transfer() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Bob, receiver: User::Alice, amount: 60 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_sender_not_registered() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer {\r\n\t\t\tsender: User::Charlie,\r\n\t\t\treceiver: User::Alice,\r\n\t\t\tamount: 50,\r\n\t\t},\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_receiver_not_registered() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer {\r\n\t\t\tsender: User::Alice,\r\n\t\t\treceiver: User::Charlie,\r\n\t\t\tamount: 50,\r\n\t\t},\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 50), (User::Bob, 50), (User::Charlie, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_sender_to_empty_balance() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Bob, receiver: User::Alice, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 150)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_4_transfer() {\r\n\tlet start = HashMap::from([(User::Alice, 100), (User::Bob, 50)]);\r\n\tlet end = AccountedCurrency::next_state(\r\n\t\t&start,\r\n\t\t&AccountingTransaction::Transfer { sender: User::Bob, receiver: User::Charlie, amount: 50 },\r\n\t);\r\n\tlet expected = HashMap::from([(User::Alice, 100), (User::Charlie, 50)]);\r\n\r\n\tassert_eq!(end, expected);\r\n}\r\n```\r\n\r\n### p5_digital_cash\r\n```rust\r\n//! In this module we design another multi-user currency system. This one is not based on\r\n//! accounts, but rather, is modelled after a paper cash system. The system tracks individual\r\n//! cash bills. Each bill has an amount and an owner, and can be spent in its entirety.\r\n//! When a state transition spends bills, new bills are created in lesser or equal amount.\r\n\r\nuse anyhow::{Error, Result};\r\n\r\nuse super::{StateMachine, User};\r\nuse std::collections::{HashMap, HashSet};\r\n\r\n/// This state machine models a multi-user currency system. It tracks a set of bills in\r\n/// circulation, and updates that set when money is transferred.\r\npub struct DigitalCashSystem;\r\n\r\n/// A single bill in the digital cash system. Each bill has an owner who is allowed to spent\r\n/// it and an amount that it is worth. It also has serial number to ensure that each bill\r\n/// is unique.\r\n#[derive(Clone, Debug, Eq, PartialEq, Hash)]\r\npub struct Bill {\r\n\towner: User,\r\n\tamount: u64,\r\n\tserial: u64,\r\n}\r\n\r\n/// The State of a digital cash system. Primarily just the set of currently circulating bills.,\r\n/// but also a counter for the next serial number.\r\n#[derive(Clone, Debug, Eq, PartialEq)]\r\npub struct State {\r\n\t/// The set of currently circulating bills\r\n\tbills: HashSet<Bill>,\r\n\t/// The next serial number to use when a bill is created.\r\n\tnext_serial: u64,\r\n}\r\n\r\nimpl State {\r\n\tpub fn new() -> Self {\r\n\t\tState { bills: HashSet::<Bill>::new(), next_serial: 0 }\r\n\t}\r\n\r\n\tpub fn set_serial(&mut self, serial: u64) {\r\n\t\tself.next_serial = serial;\r\n\t}\r\n\r\n\tpub fn next_serial(&self) -> u64 {\r\n\t\tself.next_serial\r\n\t}\r\n\r\n\tfn increment_serial(&mut self) {\r\n\t\tself.next_serial += 1\r\n\t}\r\n\r\n\tfn add_bill(&mut self, elem: Bill) {\r\n\t\tself.bills.insert(elem);\r\n\t\tself.increment_serial()\r\n\t}\r\n}\r\n\r\nimpl FromIterator<Bill> for State {\r\n\tfn from_iter<I: IntoIterator<Item = Bill>>(iter: I) -> Self {\r\n\t\tlet mut state = State::new();\r\n\r\n\t\tfor i in iter {\r\n\t\t\tstate.add_bill(i)\r\n\t\t}\r\n\t\tstate\r\n\t}\r\n}\r\n\r\nimpl<const N: usize> From<[Bill; N]> for State {\r\n\tfn from(value: [Bill; N]) -> Self {\r\n\t\tState::from_iter(value)\r\n\t}\r\n}\r\n\r\n/// The state transitions that users can make in a digital cash system\r\npub enum CashTransaction {\r\n\t/// Mint a single new bill owned by the minter\r\n\tMint { minter: User, amount: u64 },\r\n\t/// Send some money from some users to other users. The money does not all need\r\n\t/// to come from the same user, and it does not all need to go to the same user.\r\n\t/// The total amount received must be less than or equal to the amount spent.\r\n\t/// The discrepancy between the amount sent and received is destroyed. Therefore,\r\n\t/// no dedicated burn transaction is required.\r\n\tTransfer { spends: Vec<Bill>, receives: Vec<Bill> },\r\n}\r\n\r\n/// We model this system as a state machine with two possible transitions\r\nimpl StateMachine for DigitalCashSystem {\r\n\ttype State = State;\r\n\ttype Transition = CashTransaction;\r\n\r\n\tfn next_state(starting_state: &Self::State, t: &Self::Transition) -> Self::State {\r\n\t\tlet mut new_state = starting_state.clone();\r\n\t\tmatch t {\r\n\t\t\tCashTransaction::Mint { minter, amount } => {\r\n\t\t\t\t// using `add_bill` method to add a new bill with serial as `next_serial()`\r\n\t\t\t\tlet bill =\r\n\t\t\t\t\tBill { owner: *minter, amount: *amount, serial: starting_state.next_serial() };\r\n\t\t\t\tnew_state.add_bill(bill);\r\n\t\t\t},\r\n\t\t\tCashTransaction::Transfer { spends, receives } => {\r\n\t\t\t\t// if `spends` is empty, we don\'t do anything\r\n\t\t\t\tif spends.len() == 0 {\r\n\t\t\t\t\treturn new_state;\r\n\t\t\t\t}\r\n\t\t\t\t// if `receives` is empty, we remove the discrepancy from the new state\r\n\t\t\t\tif receives.len() == 0 {\r\n\t\t\t\t\tnew_state.bills = HashSet::default();\r\n\t\t\t\t\treturn new_state;\r\n\t\t\t\t}\r\n\t\t\t\t// closure to handle the transfer\r\n\t\t\t\tlet process_transfer = |new_state: &mut State| -> Result<()> {\r\n\t\t\t\t\tlet (spend_id, receive_id) = ("spend", "receive");\r\n\t\t\t\t\tlet mut visited_serial: HashMap<(&\'static str, u64), bool> = HashMap::default();\r\n\t\t\t\t\tlet mut total_spends: u64 = 0;\r\n\t\t\t\t\tlet mut total_receive: u64 = 0;\r\n\r\n\t\t\t\t\tfor s in spends {\r\n\t\t\t\t\t\t// if the `spend` bill is not exist in the current state => ERROR\r\n\t\t\t\t\t\tif !new_state.bills.contains(s) {\r\n\t\t\t\t\t\t\treturn Err(Error::msg("bill does not exist"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if the `spend` bill serial is duplicate current state => ERROR\r\n\t\t\t\t\t\tif visited_serial.contains_key(&(spend_id, s.serial)) {\r\n\t\t\t\t\t\t\treturn Err(Error::msg("invalid serial key"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// mark the current `spend` bill serial as visited so we can check with receive later\r\n\t\t\t\t\t\tvisited_serial.insert((spend_id, s.serial), true);\r\n\r\n\t\t\t\t\t\t// remove the `spend` bill from the new bill list as it is processed already\r\n\t\t\t\t\t\tnew_state.bills.remove(s);\r\n\r\n\t\t\t\t\t\t// increase the total spend amount\r\n\t\t\t\t\t\ttotal_spends = total_spends.saturating_add(s.amount);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor r in receives {\r\n\t\t\t\t\t\t// if there is a serial with invalid value => ERROR\r\n\t\t\t\t\t\tif r.serial == u64::MAX {\r\n\t\t\t\t\t\t\treturn Err(Error::msg("invalid serial key"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if the `receive` bill is same as `spend` bill, identified by serial => ERROR\r\n\t\t\t\t\t\tif visited_serial.contains_key(&(spend_id, r.serial))\r\n\t\t\t\t\t\t\t|| visited_serial.contains_key(&(receive_id, r.serial))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn Err(Error::msg("invalid serial key"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// mark the `receive` bill as visited\r\n\t\t\t\t\t\tvisited_serial.insert((receive_id, r.serial), true);\r\n\r\n\t\t\t\t\t\t// if the current `receive` bill amount is larger than `total_spends` => ERROR\r\n\t\t\t\t\t\tif r.amount > total_spends {\r\n\t\t\t\t\t\t\treturn Err(Error::msg("exceed spending amount"));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// increase the total_receive so we can check if the value is zero later\r\n\t\t\t\t\t\ttotal_receive += r.amount;\r\n\r\n\t\t\t\t\t\t// substract the total_spends with `receive` bill amount\r\n\t\t\t\t\t\ttotal_spends = total_spends.saturating_sub(r.amount);\r\n\r\n\t\t\t\t\t\t// add `receive` bill to the new state if it passes all checks\r\n\t\t\t\t\t\tnew_state.add_bill(r.clone());\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if total_receive is zero => ERROR\r\n\t\t\t\t\tif total_receive == 0 {\r\n\t\t\t\t\t\treturn Err(Error::msg("output 0 value"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tOk(())\r\n\t\t\t\t};\r\n\r\n\t\t\t\tmatch process_transfer(&mut new_state) {\r\n\t\t\t\t\tOk(_) => {\r\n\t\t\t\t\t\treturn new_state;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tErr(err) => {\r\n\t\t\t\t\t\t// for debugging\r\n\t\t\t\t\t\tprintln!("{}", err.to_string());\r\n\t\t\t\t\t},\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t}\r\n\t\tstarting_state.clone()\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn sm_5_mint_new_cash() {\r\n\tlet start = State::new();\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Mint { minter: User::Alice, amount: 20 },\r\n\t);\r\n\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_overflow_receives_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 42, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 42, serial: 0 }],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: u64::MAX, serial: 1 },\r\n\t\t\t\tBill { owner: User::Alice, amount: 42, serial: 2 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 42, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_empty_spend_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![],\r\n\t\t\treceives: vec![Bill { owner: User::Alice, amount: 15, serial: 1 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_empty_receive_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t\treceives: vec![],\r\n\t\t},\r\n\t);\r\n\tlet mut expected = State::from([]);\r\n\texpected.set_serial(1);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_output_value_0_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t\treceives: vec![Bill { owner: User::Bob, amount: 0, serial: 1 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_serial_number_already_seen_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t\treceives: vec![Bill { owner: User::Alice, amount: 18, serial: 0 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_and_receiving_same_bill_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t\treceives: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_receiving_bill_with_incorrect_serial_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 20, serial: 0 }],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 10, serial: u64::MAX },\r\n\t\t\t\tBill { owner: User::Bob, amount: 10, serial: 4000 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_bill_with_incorrect_amount_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 40, serial: 0 }],\r\n\t\t\treceives: vec![Bill { owner: User::Bob, amount: 40, serial: 1 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 20, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_same_bill_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 40, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 40, serial: 0 },\r\n\t\t\t\tBill { owner: User::Alice, amount: 40, serial: 0 },\r\n\t\t\t],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Bob, amount: 20, serial: 1 },\r\n\t\t\t\tBill { owner: User::Bob, amount: 20, serial: 2 },\r\n\t\t\t\tBill { owner: User::Alice, amount: 40, serial: 3 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 40, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_more_than_bill_fails() {\r\n\tlet start = State::from([\r\n\t\tBill { owner: User::Alice, amount: 40, serial: 0 },\r\n\t\tBill { owner: User::Charlie, amount: 42, serial: 1 },\r\n\t]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 40, serial: 0 },\r\n\t\t\t\tBill { owner: User::Charlie, amount: 42, serial: 1 },\r\n\t\t\t],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Bob, amount: 20, serial: 2 },\r\n\t\t\t\tBill { owner: User::Bob, amount: 20, serial: 3 },\r\n\t\t\t\tBill { owner: User::Alice, amount: 52, serial: 4 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([\r\n\t\tBill { owner: User::Alice, amount: 40, serial: 0 },\r\n\t\tBill { owner: User::Charlie, amount: 42, serial: 1 },\r\n\t]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_non_existent_bill_fails() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 32, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Bob, amount: 1000, serial: 32 }],\r\n\t\t\treceives: vec![Bill { owner: User::Bob, amount: 1000, serial: 33 }],\r\n\t\t},\r\n\t);\r\n\tlet expected = State::from([Bill { owner: User::Alice, amount: 32, serial: 0 }]);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_from_alice_to_all() {\r\n\tlet start = State::from([Bill { owner: User::Alice, amount: 42, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Alice, amount: 42, serial: 0 }],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 10, serial: 1 },\r\n\t\t\t\tBill { owner: User::Bob, amount: 10, serial: 2 },\r\n\t\t\t\tBill { owner: User::Charlie, amount: 10, serial: 3 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet mut expected = State::from([\r\n\t\tBill { owner: User::Alice, amount: 10, serial: 1 },\r\n\t\tBill { owner: User::Bob, amount: 10, serial: 2 },\r\n\t\tBill { owner: User::Charlie, amount: 10, serial: 3 },\r\n\t]);\r\n\texpected.set_serial(4);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_from_bob_to_all() {\r\n\tlet start = State::from([Bill { owner: User::Bob, amount: 42, serial: 0 }]);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Bob, amount: 42, serial: 0 }],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 10, serial: 1 },\r\n\t\t\t\tBill { owner: User::Bob, amount: 10, serial: 2 },\r\n\t\t\t\tBill { owner: User::Charlie, amount: 22, serial: 3 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet mut expected = State::from([\r\n\t\tBill { owner: User::Alice, amount: 10, serial: 1 },\r\n\t\tBill { owner: User::Bob, amount: 10, serial: 2 },\r\n\t\tBill { owner: User::Charlie, amount: 22, serial: 3 },\r\n\t]);\r\n\texpected.set_serial(4);\r\n\tassert_eq!(end, expected);\r\n}\r\n\r\n#[test]\r\nfn sm_5_spending_from_charlie_to_all() {\r\n\tlet mut start = State::from([\r\n\t\tBill { owner: User::Charlie, amount: 68, serial: 54 },\r\n\t\tBill { owner: User::Alice, amount: 4000, serial: 58 },\r\n\t]);\r\n\tstart.set_serial(59);\r\n\tlet end = DigitalCashSystem::next_state(\r\n\t\t&start,\r\n\t\t&CashTransaction::Transfer {\r\n\t\t\tspends: vec![Bill { owner: User::Charlie, amount: 68, serial: 54 }],\r\n\t\t\treceives: vec![\r\n\t\t\t\tBill { owner: User::Alice, amount: 42, serial: 59 },\r\n\t\t\t\tBill { owner: User::Bob, amount: 5, serial: 60 },\r\n\t\t\t\tBill { owner: User::Charlie, amount: 5, serial: 61 },\r\n\t\t\t],\r\n\t\t},\r\n\t);\r\n\tlet mut expected = State::from([\r\n\t\tBill { owner: User::Alice, amount: 4000, serial: 58 },\r\n\t\tBill { owner: User::Alice, amount: 42, serial: 59 },\r\n\t\tBill { owner: User::Bob, amount: 5, serial: 60 },\r\n\t\tBill { owner: User::Charlie, amount: 5, serial: 61 },\r\n\t]);\r\n\texpected.set_serial(62);\r\n\tassert_eq!(end, expected);\r\n}\r\n```\r\n### p6_open_ended.rs\r\n```rust\r\n//! Now is your chance to get creative. Choose a state machine that interests you and model it here.\r\n//! Get as fancy as you like. The only constraint is that it should be simple enough that you can\r\n//! realistically model it in an hour or two.\r\n//!\r\n//! Here are some ideas:\r\n//! - Board games:\r\n//!   - Chess\r\n//!   - Checkers\r\n//!   - Tic tac toe\r\n//! - Beaurocracies:\r\n//!   - Beauro of Motor Vehicles - maintains driving licenses and vehicle registrations.\r\n//!   - Public Utility Provider - Customers open accounts, consume the utility, pay their bill\r\n//!     periodically, maybe utility prices fluctuate\r\n//!   - Land ownership registry\r\n//! - Tokenomics:\r\n//!   - Token Curated Registry\r\n//!   - Prediction Market\r\n//!   - There\'s a game where there\'s a prize to be split among players and the prize grows over\r\n//!     time. Any player can stop it at any point and take most of the prize for themselves.\r\n//! - Social Systems:\r\n//!   - Social Graph\r\n//!   - Web of Trust\r\n//!   - Reputation System\r\n\r\nuse anyhow::{Error, Result};\r\nuse std::collections::{HashMap, HashSet};\r\nuse std::result::Result::Ok;\r\nuse std::vec;\r\n\r\nuse super::StateMachine;\r\n\r\ntype Row = i16;\r\ntype Col = i16;\r\ntype Position = (Row, Col);\r\n\r\n#[derive(Clone, Eq, PartialEq, Debug)]\r\nenum Color {\r\n\tBlack,\r\n\tWhite,\r\n}\r\n\r\nconst BOARD_MAX_SIZE: i16 = 8;\r\nconst BOARD_MIN_SIZE: i16 = 0;\r\n\r\nimpl Color {\r\n\tfn get_other_color(self: &Self) -> Color {\r\n\t\treturn match self {\r\n\t\t\tColor::Black => Color::White,\r\n\t\t\tColor::White => Color::Black,\r\n\t\t};\r\n\t}\r\n\r\n\tfn dir(self: &Self) -> i16 {\r\n\t\tmatch self {\r\n\t\t\tColor::White => -1,\r\n\t\t\tColor::Black => 1,\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#[derive(Clone, PartialEq, Eq, Debug)]\r\nenum ChessPiece {\r\n\tPawn(Color),\r\n\tBishop(Color),\r\n\tKnight(Color),\r\n\tRook(Color),\r\n\tQueen(Color),\r\n\tKing(Color),\r\n}\r\n\r\nfn get_rook_moves((row, col): Position) -> Vec<Position> {\r\n\tlet mut rook_moves = vec![];\r\n\tfor i in BOARD_MIN_SIZE + 1..BOARD_MAX_SIZE {\r\n\t\trook_moves.append(&mut vec![(row + i, col), (row - i, col)]);\r\n\t\trook_moves.append(&mut vec![(row, col + i), (row, col - 1)]);\r\n\t}\r\n\trook_moves\r\n}\r\n\r\nfn get_bishop_moves((row, col): Position) -> Vec<Position> {\r\n\tlet mut bishop_moves = vec![];\r\n\tfor i in BOARD_MIN_SIZE + 1..BOARD_MAX_SIZE {\r\n\t\tbishop_moves.append(&mut vec![\r\n\t\t\t(row + i, col + i),\r\n\t\t\t(row + i, col - i),\r\n\t\t\t(row - i, col + i),\r\n\t\t\t(row - i, col - i),\r\n\t\t]);\r\n\t}\r\n\tbishop_moves\r\n}\r\n\r\nimpl ChessPiece {\r\n\tpub fn get_color(self: &Self) -> Color {\r\n\t\tmatch self {\r\n\t\t\tChessPiece::Pawn(color) => return color.clone(),\r\n\t\t\tChessPiece::Bishop(color) => return color.clone(),\r\n\t\t\tChessPiece::King(color) => return color.clone(),\r\n\t\t\tChessPiece::Knight(color) => return color.clone(),\r\n\t\t\tChessPiece::Queen(color) => return color.clone(),\r\n\t\t\tChessPiece::Rook(color) => return color.clone(),\r\n\t\t};\r\n\t}\r\n\r\n\tpub fn get_moves(self: &Self, pos: Position) -> HashSet<Position> {\r\n\t\tlet row = pos.0 as i16;\r\n\t\tlet col = pos.1 as i16;\r\n\t\tlet mut moves = HashSet::default();\r\n\t\tlet chess_moves: Vec<Position> = match self {\r\n\t\t\tChessPiece::Bishop(_) => get_bishop_moves(pos),\r\n\t\t\tChessPiece::Rook(_) => get_rook_moves(pos),\r\n\t\t\tChessPiece::King(_) => {\r\n\t\t\t\tvec![\r\n\t\t\t\t\t(row + 1, col + 1),\r\n\t\t\t\t\t(row + 1, col),\r\n\t\t\t\t\t(row + 1, col - 1),\r\n\t\t\t\t\t(row, col + 1),\r\n\t\t\t\t\t(row, col - 1),\r\n\t\t\t\t\t(row - 1, col + 1),\r\n\t\t\t\t\t(row - 1, col),\r\n\t\t\t\t\t(row - 1, col - 1),\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\tChessPiece::Knight(_) => {\r\n\t\t\t\tvec![\r\n\t\t\t\t\t(row + 2, col + 1),\r\n\t\t\t\t\t(row + 2, col - 1),\r\n\t\t\t\t\t(row - 2, col + 1),\r\n\t\t\t\t\t(row - 2, col - 1),\r\n\t\t\t\t\t(row + 1, col + 2),\r\n\t\t\t\t\t(row + 1, col - 2),\r\n\t\t\t\t\t(row - 1, col + 2),\r\n\t\t\t\t\t(row - 1, col - 2),\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\tChessPiece::Pawn(color) => {\r\n\t\t\t\tlet d = color.dir();\r\n\t\t\t\tvec![(row + d, col + 1), (row - d, col - 1)]\r\n\t\t\t},\r\n\t\t\tChessPiece::Queen(_) => {\r\n\t\t\t\tlet rook_moves = get_rook_moves(pos);\r\n\t\t\t\tlet bishop_moves = get_bishop_moves(pos);\r\n\t\t\t\t[rook_moves, bishop_moves].concat()\r\n\t\t\t},\r\n\t\t};\r\n\t\tfor (row, col) in chess_moves {\r\n\t\t\t// chess moves out of the board\r\n\t\t\tif row > BOARD_MAX_SIZE\r\n\t\t\t\t|| col > BOARD_MAX_SIZE\r\n\t\t\t\t|| row <= BOARD_MIN_SIZE\r\n\t\t\t\t|| col <= BOARD_MIN_SIZE\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tmoves.insert((row, col));\r\n\t\t}\r\n\t\treturn moves;\r\n\t}\r\n}\r\n\r\n#[derive(Clone, PartialEq, Eq, Debug)]\r\nenum ChessGameStatus {\r\n\tFinished(Color),\r\n\tRunning,\r\n}\r\n\r\n#[derive(Clone, PartialEq, Eq, Debug)]\r\npub struct State {\r\n\t/// Chess Board\r\n\t/// \t\t\t\tColumn\r\n\t/// \t\t\t\t\t\t|\r\n\t///   \t\t\t\t| 1 2 3 4 5 6 7 8\r\n\t/// Row - - - - - - - - - -\r\n\t/// \t\t\t\t1 | R k B Q K B k R\r\n\t/// \t\t\t\t2 | P P P P P P P P\r\n\t/// \t\t\t\t3 |\r\n\t/// \t\t\t\t4 |\r\n\t/// \t\t\t\t5 |\r\n\t/// \t\t\t\t6 |\r\n\t/// \t\t\t\t7 | P P P P P P P P\r\n\t/// \t\t\t\t8 | R k B Q K B k R\r\n\tboard: HashMap<Position, ChessPiece>,\r\n\tside_color: Color,\r\n\tstatus: ChessGameStatus,\r\n\tmoves: u64,\r\n}\r\n\r\nimpl Default for State {\r\n\tfn default() -> Self {\r\n\t\tState {\r\n\t\t\tmoves: 0,\r\n\t\t\tstatus: ChessGameStatus::Running,\r\n\t\t\tside_color: Color::White,\r\n\t\t\tboard: HashMap::from([\r\n\t\t\t\t((1, 1), ChessPiece::Rook(Color::Black)),\r\n\t\t\t\t((1, 2), ChessPiece::Knight(Color::Black)),\r\n\t\t\t\t((1, 3), ChessPiece::Bishop(Color::Black)),\r\n\t\t\t\t((1, 4), ChessPiece::Queen(Color::Black)),\r\n\t\t\t\t((1, 5), ChessPiece::King(Color::Black)),\r\n\t\t\t\t((1, 6), ChessPiece::Bishop(Color::Black)),\r\n\t\t\t\t((1, 7), ChessPiece::Knight(Color::Black)),\r\n\t\t\t\t((1, 8), ChessPiece::Rook(Color::Black)),\r\n\t\t\t\t((2, 1), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 2), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 3), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 4), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 5), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 6), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 7), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((2, 8), ChessPiece::Pawn(Color::Black)),\r\n\t\t\t\t((7, 1), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 2), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 3), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 4), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 5), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 6), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 7), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((7, 8), ChessPiece::Pawn(Color::White)),\r\n\t\t\t\t((8, 1), ChessPiece::Rook(Color::White)),\r\n\t\t\t\t((8, 2), ChessPiece::Knight(Color::White)),\r\n\t\t\t\t((8, 3), ChessPiece::Bishop(Color::White)),\r\n\t\t\t\t((8, 4), ChessPiece::Queen(Color::White)),\r\n\t\t\t\t((8, 5), ChessPiece::King(Color::White)),\r\n\t\t\t\t((8, 6), ChessPiece::Bishop(Color::White)),\r\n\t\t\t\t((8, 7), ChessPiece::Knight(Color::White)),\r\n\t\t\t\t((8, 8), ChessPiece::Rook(Color::White)),\r\n\t\t\t]),\r\n\t\t}\r\n\t}\r\n}\r\n\r\npub enum Transition {\r\n\t#[allow(unused)]\r\n\tMove { chess_piece: ChessPiece, from: Position, to: Position },\r\n}\r\n\r\nimpl State {\r\n\tfn incre_move(self: &mut Self) {\r\n\t\tself.moves += 1;\r\n\t}\r\n\r\n\tfn board_move(self: &mut Self, from_pos: Position, to_pos: Position) -> Option<ChessPiece> {\r\n\t\tlet pos_element = self.board.get(&from_pos);\r\n\t\tif let Some(element) = pos_element {\r\n\t\t\tlet option = self.board.insert(to_pos, element.clone());\r\n\t\t\tif option.is_some() {\r\n\t\t\t\treturn option;\r\n\t\t\t}\r\n\t\t\tself.board.remove(&from_pos);\r\n\t\t}\r\n\t\tself.incre_move();\r\n\t\treturn None;\r\n\t}\r\n\r\n\tfn next_color(self: &mut Self, color: Color) {\r\n\t\tself.side_color = color.get_other_color();\r\n\t}\r\n}\r\n\r\nimpl StateMachine for State {\r\n\ttype State = State;\r\n\ttype Transition = Transition;\r\n\r\n\tfn human_name() -> String {\r\n\t\treturn String::from("Chess State Machine");\r\n\t}\r\n\r\n\tfn next_state(starting_state: &Self::State, t: &Self::Transition) -> Self::State {\r\n\t\tlet mut updated_state = starting_state.clone();\r\n\r\n\t\tlet process_state = |updated_state: &mut State| -> Result<()> {\r\n\t\t\tmatch t {\r\n\t\t\t\tTransition::Move { chess_piece, from, to } => {\r\n\t\t\t\t\tlet chess_piece_color = chess_piece.get_color();\r\n\t\t\t\t\tlet enemy_color = chess_piece_color.get_other_color();\r\n\r\n\t\t\t\t\tif chess_piece_color != starting_state.side_color {\r\n\t\t\t\t\t\treturn Err(Error::msg("wrong side color"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet get_chess_from_pos = starting_state.board.get(from);\r\n\t\t\t\t\tif get_chess_from_pos.is_none() || get_chess_from_pos.unwrap() != chess_piece {\r\n\t\t\t\t\t\treturn Err(Error::msg("chess piece is not at `from` position"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet possible_moves = chess_piece.get_moves(*from);\r\n\t\t\t\t\tif !possible_moves.contains(to) {\r\n\t\t\t\t\t\treturn Err(Error::msg("invalid move"));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor possible_move in possible_moves {\r\n\t\t\t\t\t\tif let Some(board_chess) = starting_state.board.get(&possible_move) {\r\n\t\t\t\t\t\t\tif board_chess.get_color() == chess_piece_color {\r\n\t\t\t\t\t\t\t\t// possible move lands on same side chess piece\r\n\t\t\t\t\t\t\t\treturn Err(Error::msg(\r\n\t\t\t\t\t\t\t\t\t"position is occupied by other same side chess",\r\n\t\t\t\t\t\t\t\t));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// this also covers a case of enemy chess piece is killed\r\n\t\t\t\t\tif let Some(killed_chess_piece) = updated_state.board_move(*from, *to) {\r\n\t\t\t\t\t\tif killed_chess_piece == ChessPiece::King(enemy_color) {\r\n\t\t\t\t\t\t\tupdated_state.status =\r\n\t\t\t\t\t\t\t\tChessGameStatus::Finished(chess_piece_color.clone());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated_state.next_color(chess_piece_color);\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t\tOk(())\r\n\t\t};\r\n\r\n\t\tmatch process_state(&mut updated_state) {\r\n\t\t\tOk(_) => {\r\n\t\t\t\treturn updated_state;\r\n\t\t\t},\r\n\t\t\tErr(err) => {\r\n\t\t\t\tprintln!("{}", err.to_string());\r\n\t\t\t\treturn starting_state.clone();\r\n\t\t\t},\r\n\t\t};\r\n\t}\r\n}\r\nmod test {\r\n\t#[allow(unused)]\r\n\tuse super::*;\r\n\r\n\t#[test]\r\n\tfn test_wrong_side_color() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::Pawn(Color::Black),\r\n\t\t\t\tfrom: (7, 1),\r\n\t\t\t\tto: (7, 3),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet expected = State::default();\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_pawn_move_failed_invalid_move() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::Pawn(Color::White),\r\n\t\t\t\tfrom: (7, 1),\r\n\t\t\t\tto: (8, 8),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet expected = State::default();\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_success_move_pawn() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::Pawn(Color::White),\r\n\t\t\t\tfrom: (7, 1),\r\n\t\t\t\tto: (6, 2),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet mut expected = State::default();\r\n\t\texpected.board_move((7, 1), (6, 2));\r\n\t\texpected.next_color(Color::White);\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_invalid_bishop_move() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::Bishop(Color::White),\r\n\t\t\t\tfrom: (8, 3),\r\n\t\t\t\tto: (7, 3),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet expected = State::default();\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_success_move_bishop() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::Bishop(Color::White),\r\n\t\t\t\tfrom: (8, 3),\r\n\t\t\t\tto: (7, 4),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet mut expected = State::default();\r\n\t\texpected.board_move((8, 3), (7, 4));\r\n\t\texpected.next_color(Color::White);\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_invalid_king_move() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::King(Color::White),\r\n\t\t\t\tfrom: (8, 5),\r\n\t\t\t\tto: (8, 7),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet expected = State::default();\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n\r\n\t#[test]\r\n\tfn test_success_move_king() {\r\n\t\tlet state = State::default();\r\n\t\tlet end = State::next_state(\r\n\t\t\t&state,\r\n\t\t\t&Transition::Move {\r\n\t\t\t\tchess_piece: ChessPiece::King(Color::White),\r\n\t\t\t\tfrom: (8, 5),\r\n\t\t\t\tto: (8, 4),\r\n\t\t\t},\r\n\t\t);\r\n\t\tlet mut expected = State::default();\r\n\t\texpected.board_move((8, 5), (8, 4));\r\n\t\texpected.next_color(Color::White);\r\n\t\tassert_eq!(end, expected);\r\n\t}\r\n}\r\n```</div>',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [
                  {
                    login: 'chungquantin',
                  },
                ],
                pageInfo: {
                  startCursor: 'MQ',
                  endCursor: 'MQ',
                  hasNextPage: false,
                },
                totalCount: 1,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856y69E',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Prepare for PBA  üìô] Rust Practices with Mock Qualification Exam for PBA ü¶Ä',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 3,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: '2024-01-03T07:12:36Z',
              body: '## Description\r\n\r\nCreating a mock qualification exam based on https://github.com/Polkadot-Blockchain-Academy/pba-qualifier-exam/tree/main/src covering topics above.\r\n\r\n## Issue Guidelines\r\n- [ ] Craft a mock qualification exam\r\n- [ ] Provide solutions and instructions to solve the qualification exam\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [
                  {
                    reactions: {
                      viewerHasReacted: true,
                      totalCount: 1,
                    },
                    publishedAt: '2024-01-03T07:11:02Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 0,
                    },
                    publishedAt: '2024-01-03T07:14:48Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: true,
                      totalCount: 1,
                    },
                    publishedAt: '2024-01-03T07:27:28Z',
                  },
                  {
                    reactions: {
                      viewerHasReacted: false,
                      totalCount: 2,
                    },
                    publishedAt: '2024-01-03T07:37:00Z',
                  },
                ],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856y-oS',
              activeLockReason: null,
              state: 'OPEN',
              title:
                '[Substrate Pallet Development üíª] Introduce FRAME pallet and break down structure of pallet',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 3,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '## Description\r\n\r\nIntroducing basic concepts of FRAME pallets and breaking down the structure of a pallet.\r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who owns the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856zGXL',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Substrate Pallet Development üíª] Build a simple proof of existence pallet ',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 3,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '## Description\r\n\r\nGuide the user on how to write a simple pallet using proof of existence as an example\r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who owns the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu856zG-n',
              activeLockReason: null,
              state: 'OPEN',
              title:
                '[Substrate Pallet Development üíª] Learn off-chain workers and build an oracle as an example',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 3,
                nodes: [
                  {
                    name: 'good first issue',
                    color: '7057ff',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'help wanted',
                    color: '008672',
                    createdAt: '2023-11-20T14:52:19Z',
                    isDefault: true,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: '## Description\r\n\r\nFetching off-chain data with off-chain workers and building an oracle as an example\r\n\r\n## Issue Guidelines\r\nThere are two ways of working on this issue, you can choose one of the following:\r\n1. Record a video working through a problem set with instructions from the presenter so the audience can understand and learn from the videos.\r\n2. Write a README article on how to solve a set of problems in the repository and publish it on **https://lowlevelers.com**\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who owns the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n',
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [],
                pageInfo: {
                  startCursor: null,
                  endCursor: null,
                  hasNextPage: false,
                },
                totalCount: 0,
              },
            },
          },
          {
            node: {
              id: 'I_kwDOKvyTu8565jKt',
              activeLockReason: null,
              state: 'OPEN',
              title: '[Prepare for PBA üìô] pba_book: blockchain from scratch (c2_blockchain)',
              stateReason: null,
              closedAt: null,
              labels: {
                __typename: 'LabelConnection',
                totalCount: 2,
                nodes: [
                  {
                    name: 'article-and-blog',
                    color: 'FAF246',
                    createdAt: '2023-12-23T17:10:32Z',
                    isDefault: false,
                  },
                  {
                    name: 'allow-multiple-contributor',
                    color: '9BE222',
                    createdAt: '2023-12-28T13:26:25Z',
                    isDefault: false,
                  },
                ],
              },
              isPinned: false,
              lastEditedAt: null,
              body: "## Description\r\n### p1_header_chain.rs\r\n```rust\r\n//! We want to make the simplest possible blockchain to begin with. Just a hash-linked data\r\n//! structure. We learned from the lecture that it is actually the headers that are hash linked, so\r\n//! let's start with that.\r\n\r\nuse crate::hash;\r\n\r\n// We will use Rust's built-in hashing where the output type is u64. I'll make an alias\r\n// so the code is slightly more readable.\r\ntype Hash = u64;\r\n\r\n/// The most basic blockchain header possible. We learned its basic structure from lecture.\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Header {\r\n\tparent: Hash,\r\n\theight: u64,\r\n\t// We know from the lecture that we will probably need these, but we don't need them yet.\r\n\textrinsics_root: (),\r\n\tstate_root: (),\r\n\tconsensus_digest: (),\r\n}\r\n\r\n// Here are the methods for creating a new header and verifying headers.\r\n// It is your job to write them.\r\nimpl Header {\r\n\t/// Returns a new valid genesis header.\r\n\tfn genesis() -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: 0,\r\n\t\t\tparent: Hash::default(),\r\n\t\t\tstate_root: (),\r\n\t\t\textrinsics_root: (),\r\n\t\t\tconsensus_digest: (),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Create and return a valid child header.\r\n\tfn child(&self) -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: self.height + 1,\r\n\t\t\tparent: hash(self),\r\n\t\t\tstate_root: (),\r\n\t\t\textrinsics_root: (),\r\n\t\t\tconsensus_digest: (),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Verify that all the given headers form a valid chain from this header to the tip.\r\n\t/// An \"entire\" chain can be verified by calling this method on a genesis header.\r\n\t/// This method may assume that the block on which it is called is valid, but it\r\n\t/// must verify all of the blocks in the slice;\r\n\tfn verify_sub_chain(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut curr_hash = hash(self);\r\n\t\tlet mut is_verified: bool = true;\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\tlet mut curr_height = self.height;\r\n\t\twhile let Some(header) = chain_iter.next() {\r\n\t\t\tif header.height - curr_height != 1 {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tis_verified &= header.parent == curr_hash;\r\n\t\t\tcurr_hash = hash(header);\r\n\t\t\tcurr_height = header.height;\r\n\t\t}\r\n\t\tis_verified\r\n\t}\r\n}\r\n\r\n// And finally a few functions to use the code we just\r\n\r\n/// Build and return a valid chain with exactly five blocks including the genesis block.\r\nfn build_valid_chain_length_5() -> Vec<Header> {\r\n\tlet g = Header::genesis();\r\n\tlet mut curr_header = g.clone();\r\n\tlet mut chain = vec![curr_header.clone()];\r\n\tfor _ in 0..4 {\r\n\t\tchain.push(curr_header.child());\r\n\t\tcurr_header = curr_header.child();\r\n\t}\r\n\treturn chain;\r\n}\r\n\r\n/// Build and return a chain with at least three headers.\r\n/// The chain should start with a proper genesis header,\r\n/// but the entire chain should NOT be valid.\r\nfn build_an_invalid_chain() -> Vec<Header> {\r\n\tlet g = Header::genesis();\r\n\tlet curr_header = g.clone();\r\n\tlet mut chain = vec![curr_header.clone()];\r\n\tfor _ in 0..2 {\r\n\t\tchain.push(curr_header.child());\r\n\t}\r\n\treturn chain;\r\n}\r\n\r\n// To run these tests: `cargo test bc_1\r\n#[test]\r\nfn bc_1_genesis_block_height() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.height == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_1_genesis_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.parent == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_1_child_block_height() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child();\r\n\tassert!(b1.height == 1);\r\n}\r\n\r\n#[test]\r\nfn bc_1_child_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child();\r\n\tassert!(b1.parent == hash(&g));\r\n}\r\n\r\n#[test]\r\nfn bc_1_verify_genesis_only() {\r\n\tlet g = Header::genesis();\r\n\r\n\tassert!(g.verify_sub_chain(&[]));\r\n}\r\n\r\n#[test]\r\nfn bc_1_verify_three_blocks() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child();\r\n\tlet b2 = b1.child();\r\n\r\n\tassert!(g.verify_sub_chain(&[b1, b2]));\r\n}\r\n\r\n#[test]\r\nfn bc_1_cant_verify_invalid_height() {\r\n\t// This and following tests use the student's own verify function so as\r\n\t// not to give away the solution to writing that function.\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child();\r\n\tb1.height = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]))\r\n}\r\n\r\n#[test]\r\nfn bc_1_cant_verify_invalid_parent() {\r\n\t// This test chooses to use the student's own verify function so as\r\n\t// not to give away the solution to writing that function.\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child();\r\n\tb1.parent = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]))\r\n}\r\n\r\n#[test]\r\nfn bc_1_verify_chain_length_five() {\r\n\t// This test chooses to use the student's own verify function.\r\n\t// This should be relatively safe given that we have already tested that function.\r\n\tlet chain = build_valid_chain_length_5();\r\n\tassert!(chain[0].verify_sub_chain(&chain[1..]))\r\n}\r\n\r\n#[test]\r\nfn bc_1_invalid_chain_is_really_invalid() {\r\n\t// This test chooses to use the student's own verify function.\r\n\t// This should be relatively safe given that we have already tested that function.\r\n\tlet invalid_chain = build_an_invalid_chain();\r\n\tassert!(!invalid_chain[0].verify_sub_chain(&invalid_chain[1..]))\r\n}\r\n\r\n```\r\n\r\n### p2_extrinsic_state\r\n```rust\r\n//! Now that we have a functioning hash-linked data structure, we can use it to actually\r\n//! track some state. Here we will start to explore the idea of extrinsics and state by\r\n//! slightly abusing the header's extrinsics_root and state_root fields. As the names imply,\r\n//! these are typically used for Merkle roots of large data sets. But in our case we will use\r\n//! these fields to directly contain a single extrinsic per block, and a single piece of state.\r\n//!\r\n//! In the coming parts of this tutorial, we will expand this to be more real-world like and\r\n//! use some real batching.\r\n\r\nuse crate::hash;\r\n\r\n// We will use Rust's built-in hashing where the output type is u64. I'll make an alias\r\n// so the code is slightly more readable.\r\ntype Hash = u64;\r\n\r\n/// The header is now expanded to contain an extrinsic and a state. Note that we are not\r\n/// using roots yet, but rather directly embedding some minimal extrinsic and state info\r\n/// into the header.\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Header {\r\n\tparent: Hash,\r\n\theight: u64,\r\n\textrinsic: u64,\r\n\tstate: u64,\r\n\t// Still no consensus. That's the next part.\r\n\tconsensus_digest: (),\r\n}\r\n\r\n// Here are the methods for creating new header and verifying headers.\r\n// It is your job to write them.\r\nimpl Header {\r\n\t/// Returns a new valid genesis header.\r\n\tfn genesis() -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: 0,\r\n\t\t\tparent: Hash::default(),\r\n\t\t\tstate: Hash::default(),\r\n\t\t\textrinsic: Hash::default(),\r\n\t\t\tconsensus_digest: (),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Create and return a valid child header.\r\n\t///\r\n\t/// This blockchain will work as an adder. That means that the state starts at zero,\r\n\t/// and at each block we add the extrinsic to the state.\r\n\tfn child(&self, extrinsic: u64) -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: self.height + 1,\r\n\t\t\tparent: hash(self),\r\n\t\t\tstate: self.state + extrinsic,\r\n\t\t\textrinsic,\r\n\t\t\tconsensus_digest: (),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Verify that all the given headers form a valid chain from this header to the tip.\r\n\t///\r\n\t/// In addition to the consecutive heights and linked hashes, we now need to consider our state.\r\n\t///\r\n\t/// So in order for a block to verify, we must have the above explained relationship between the\r\n\t/// extrinsic, the previous state, and the current state.\r\n\tfn verify_sub_chain(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut curr_header = self;\r\n\t\tlet mut is_verified: bool = true;\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\tlet mut curr_height = self.height;\r\n\t\twhile let Some(header) = chain_iter.next() {\r\n\t\t\tif header.height - curr_height != 1 {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tis_verified &= header.parent == hash(curr_header)\r\n\t\t\t\t&& header.state == curr_header.state + header.extrinsic;\r\n\t\t\tcurr_header = header;\r\n\t\t\tcurr_height = header.height;\r\n\t\t}\r\n\t\tis_verified\r\n\t}\r\n}\r\n\r\n// And finally a few functions to use the code we just\r\n\r\n/// Build and return a valid chain with the given number of blocks.\r\nfn build_valid_chain(n: u64) -> Vec<Header> {\r\n\tlet g = Header::genesis();\r\n\tlet mut curr_header = g.clone();\r\n\tlet mut chain = vec![curr_header.clone()];\r\n\tfor extrinsic in 0..(n - 1) {\r\n\t\tchain.push(curr_header.child(extrinsic));\r\n\t\tcurr_header = curr_header.child(extrinsic);\r\n\t}\r\n\treturn chain;\r\n}\r\n\r\n/// Build and return a chain with at least three headers.\r\n/// The chain should start with a proper genesis header,\r\n/// but the entire chain should NOT be valid.\r\n///\r\n/// As we saw in the last unit, this is trivial when we construct arbitrary blocks.\r\n/// However, from outside this crate, it is not so trivial. Our interface for creating\r\n/// new blocks, `genesis()` and `child()`, makes it impossible to create arbitrary blocks.\r\n///\r\n/// For this function, ONLY USE the the `genesis()` and `child()` methods to create blocks.\r\n/// The exercise is still possible.\r\nfn build_an_invalid_chain() -> Vec<Header> {\r\n\ttodo!(\"Exercise 5\")\r\n}\r\n\r\n/// Build and return two header chains.\r\n/// Both chains should individually be valid.\r\n/// They should have the same genesis header.\r\n/// They should not be the exact same chain.\r\n///\r\n/// Here is an example of two such chains:\r\n///            /-- 3 -- 4\r\n/// G -- 1 -- 2\r\n///            \\-- 3'-- 4'\r\n///\r\n/// Side question: What is the fewest number of headers you could create to achieve this goal.\r\nfn build_forked_chain() -> (Vec<Header>, Vec<Header>) {\r\n\tlet chain = build_valid_chain(3);\r\n\r\n\tlet shared_header = chain.last().unwrap();\r\n\r\n\tlet mut forked_chain_a = chain.clone();\r\n\tlet mut curr_forked_header = shared_header.clone();\r\n\tfor extrinsic in 3..=4 {\r\n\t\tforked_chain_a.push(curr_forked_header.child(extrinsic));\r\n\t\tcurr_forked_header = curr_forked_header.child(extrinsic);\r\n\t}\r\n\r\n\tlet mut forked_chain_b = chain.clone();\r\n\tlet mut curr_forked_header = shared_header.clone();\r\n\tfor extrinsic in 13..=14 {\r\n\t\tforked_chain_b.push(curr_forked_header.child(extrinsic));\r\n\t\tcurr_forked_header = curr_forked_header.child(extrinsic);\r\n\t}\r\n\treturn (forked_chain_a, forked_chain_b);\r\n\r\n\t// Exercise 7: After you have completed this task, look at how its test is written below.\r\n\t// There is a critical thinking question for you there.\r\n}\r\n\r\n// To run these tests: `cargo test bc_2`\r\n#[test]\r\nfn bc_2_genesis_block_height() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.height == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_2_genesis_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.parent == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_2_genesis_block_extrinsic() {\r\n\t// Typically genesis blocks do not have any extrinsics.\r\n\t// In Substrate they never do. So our convention is to have the extrinsic be 0.\r\n\tlet g = Header::genesis();\r\n\tassert!(g.extrinsic == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_2_genesis_block_state() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.state == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_2_child_block_height() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(0);\r\n\tassert!(b1.height == 1);\r\n}\r\n\r\n#[test]\r\nfn bc_2_child_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(0);\r\n\tassert!(b1.parent == hash(&g));\r\n}\r\n\r\n#[test]\r\nfn bc_2_child_block_extrinsic() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(7);\r\n\tassert_eq!(b1.extrinsic, 7);\r\n}\r\n\r\n#[test]\r\nfn bc_2_child_block_state() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(7);\r\n\tassert_eq!(b1.state, 7);\r\n}\r\n\r\n#[test]\r\nfn bc_2_verify_genesis_only() {\r\n\tlet g = Header::genesis();\r\n\r\n\tassert!(g.verify_sub_chain(&[]));\r\n}\r\n\r\n#[test]\r\nfn bc_2_verify_three_blocks() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(5);\r\n\tlet b2 = b1.child(6);\r\n\r\n\tassert_eq!(b2.state, 11);\r\n\tassert!(g.verify_sub_chain(&[b1, b2]));\r\n}\r\n\r\n#[test]\r\nfn bc_2_cant_verify_invalid_parent() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.parent = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_2_cant_verify_invalid_number() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.height = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_2_cant_verify_invalid_state() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.state = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_2_verify_forked_chain() {\r\n\tlet g = Header::genesis();\r\n\tlet (c1, c2) = build_forked_chain();\r\n\r\n\t// Both chains have the same valid genesis block\r\n\tassert_eq!(g, c1[0]);\r\n\tassert_eq!(g, c2[0]);\r\n\r\n\t// Both chains are individually valid\r\n\tassert!(g.verify_sub_chain(&c1[1..]));\r\n\tassert!(g.verify_sub_chain(&c2[1..]));\r\n\r\n\t// The two chains are not identical\r\n\t// Question for students: I've only compared the last blocks here.\r\n\t// Is that enough? Is it possible that the two chains have the same final block,\r\n\t// but differ somewhere else?\r\n\tassert_ne!(c1.last(), c2.last());\r\n}\r\n```\r\n### p3_consensus.rs\r\n```rust\r\n//! We now have a hash-linked header chain that accepts simple extrinsics and tracks simple state.\r\n//! Now we will explore consensus. We are not looking at finality or fork choice here. Rather,\r\n//! we are adding validity rules. There are two common types of validity rules and we will explore\r\n//! both.\r\n//! 1. Rules to throttle authoring. In this case we will use a simple PoW.\r\n//! 2. Arbitrary / Political rules. Here we will implement two alternate validity rules\r\n\r\nuse crate::hash;\r\n\r\nuse rand::Rng;\r\n\r\n// We will use Rust's built-in hashing where the output type is u64. I'll make an alias\r\n// so the code is slightly more readable.\r\ntype Hash = u64;\r\n\r\n/// In this lesson we are introducing proof of work onto our blocks. We need a hash threshold.\r\n/// You may change this as you see fit, and I encourage you to experiment. Probably best to start\r\n/// high so we aren't wasting time mining. I'll start with 1 in 100 blocks being valid.\r\nconst THRESHOLD: u64 = u64::max_value() / 100;\r\n\r\n/// In this lesson we introduce the concept of a contentious hard fork. The fork will happen at\r\n/// this block height.\r\nconst FORK_HEIGHT: u64 = 2;\r\n\r\n/// The header is now expanded to contain a consensus digest.\r\n/// For Proof of Work, the consensus digest is basically just a nonce which gets the block\r\n/// hash below a certain threshold. Although we could call the field `nonce` we will leave\r\n/// the more general `digest` term. For PoA we would have a cryptographic signature in this field.\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Header {\r\n\tparent: Hash,\r\n\theight: u64,\r\n\textrinsic: u64,\r\n\tstate: u64,\r\n\tconsensus_digest: u64,\r\n}\r\n\r\n// Here are the methods for creating new header and verifying headers.\r\n// It is your job to write them.\r\nimpl Header {\r\n\tfn generate_nonce(&self) -> u64 {\r\n\t\tlet mut rng = rand::thread_rng();\r\n\t\treturn rng.gen::<u32>() as u64;\r\n\t}\r\n\r\n\t/// Returns a new valid genesis header.\r\n\tfn genesis() -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: 0,\r\n\t\t\tparent: Hash::default(),\r\n\t\t\tstate: 0,\r\n\t\t\textrinsic: 0,\r\n\t\t\tconsensus_digest: 0,\r\n\t\t};\r\n\t}\r\n\r\n\t/// Create and return a valid child header.\r\n\tfn child(&self, extrinsic: u64) -> Self {\r\n\t\tlet mut valid_header: Header = Self {\r\n\t\t\theight: self.height + 1,\r\n\t\t\tparent: hash(self),\r\n\t\t\tstate: self.state + extrinsic,\r\n\t\t\textrinsic,\r\n\t\t\tconsensus_digest: Hash::default(),\r\n\t\t};\r\n\t\tloop {\r\n\t\t\tlet nonce = self.generate_nonce();\r\n\t\t\tvalid_header.consensus_digest = nonce;\r\n\t\t\tif hash(&valid_header) < THRESHOLD {\r\n\t\t\t\treturn valid_header;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfn is_header_verified(prev_header: &Header, header: &Header) -> bool {\r\n\t\tif header.height.saturating_sub(prev_header.height) != 1 {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet valid_hash = header.parent == hash(prev_header);\r\n\t\tlet valid_extrinsic = header.state == prev_header.state + header.extrinsic;\r\n\t\tlet valid_consensus_digest = hash(header) < THRESHOLD;\r\n\t\treturn valid_hash && valid_extrinsic && valid_consensus_digest;\r\n\t}\r\n\r\n\t/// Verify that all the given headers form a valid chain from this header to the tip.\r\n\t///\r\n\t/// In addition to all the rules we had before, we now need to check that the block hash\r\n\t/// is below a specific threshold.\r\n\tfn verify_sub_chain(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut prev_header = self;\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\twhile let Some(header) = chain_iter.next() {\r\n\t\t\tif !Header::is_header_verified(prev_header, header) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tprev_header = header;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// After the blockchain ran for a while, a political rift formed in the community.\r\n\t// (See the constant FORK_HEIGHT) which is set to 2 by default.\r\n\t// Most community members have become obsessed over the state of the blockchain.\r\n\t// On the one side, people believe that only blocks with even states should be valid.\r\n\t// On the other side, people believe in only blocks with odd states.\r\n\r\n\t/// verify that the given headers form a valid chain.\r\n\t/// In this case \"valid\" means that the STATE MUST BE EVEN.\r\n\tfn verify_sub_chain_even(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut prev_header = self;\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\twhile let Some(header) = chain_iter.next() {\r\n\t\t\tif header.height > FORK_HEIGHT && header.state % 2 != 0 {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif !Header::is_header_verified(prev_header, header) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tprev_header = header;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/// verify that the given headers form a valid chain.\r\n\t/// In this case \"valid\" means that the STATE MUST BE ODD.\r\n\tfn verify_sub_chain_odd(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut prev_header = self;\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\twhile let Some(header) = chain_iter.next() {\r\n\t\t\tif header.height > FORK_HEIGHT && header.state % 2 != 1 {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif !Header::is_header_verified(prev_header, header) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tprev_header = header;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/// Build and return two different chains with a common prefix.\r\n/// They should have the same genesis header.\r\n///\r\n/// Both chains should be valid according to the original validity rules.\r\n/// The first chain should be valid only according to the even rules.\r\n/// The second chain should be valid only according to the odd rules.\r\n///\r\n/// Return your solutions as three vectors:\r\n/// 1. The common prefix including genesis\r\n/// 2. The even suffix (non-overlapping with the common prefix)\r\n/// 3. The odd suffix (non-overlapping with the common prefix)\r\n///\r\n/// Here is an example of two such chains:\r\n///            /-- 3 -- 4\r\n/// G -- 1 -- 2\r\n///            \\-- 3'-- 4'\r\nfn build_contentious_forked_chain() -> (Vec<Header>, Vec<Header>, Vec<Header>) {\r\n\tlet g = Header::genesis(); // state = 0\r\n\tlet b1 = g.child(5); // state = 5\r\n\tlet b2 = b1.child(6); // state = 11\r\n\tlet chain = vec![b1, b2];\r\n\r\n\tlet forked_header = chain.last().unwrap();\r\n\r\n\tlet forked_even_header_a = forked_header.child(3); // state = 14\r\n\tlet forked_even_header_b = forked_even_header_a.child(2); // state = 16\r\n\r\n\tlet forked_odd_chain_a = forked_header.child(4); // state = 15\r\n\tlet forked_odd_chain_b = forked_odd_chain_a.child(2); // state = 17\r\n\r\n\treturn (\r\n\t\tchain.clone(),\r\n\t\tvec![forked_even_header_a, forked_even_header_b],\r\n\t\tvec![forked_odd_chain_a, forked_odd_chain_b]);\r\n}\r\n\r\n// To run these tests: `cargo test bc_3`\r\n#[test]\r\nfn bc_3_genesis_block_height() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.height == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_3_genesis_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.parent == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_3_genesis_block_extrinsic() {\r\n\t// Typically genesis blocks do not have any extrinsics.\r\n\t// In Substrate they never do. So our convention is to have the extrinsic be 0.\r\n\tlet g = Header::genesis();\r\n\tassert!(g.extrinsic == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_3_genesis_block_state() {\r\n\tlet g = Header::genesis();\r\n\tassert!(g.state == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_3_genesis_consensus_digest() {\r\n\t// We could require that the genesis block have a valid proof of work as well.\r\n\t// But instead I've chosen the simpler path of defining the nonce = 0 in genesis.\r\n\tlet g = Header::genesis();\r\n\tassert!(g.consensus_digest == 0);\r\n}\r\n\r\n#[test]\r\nfn bc_3_child_block_height() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(0);\r\n\tassert!(b1.height == 1);\r\n}\r\n\r\n#[test]\r\nfn bc_3_child_block_parent() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(0);\r\n\tassert!(b1.parent == hash(&g));\r\n}\r\n\r\n#[test]\r\nfn bc_3_child_block_extrinsic() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(7);\r\n\tassert_eq!(b1.extrinsic, 7);\r\n}\r\n\r\n#[test]\r\nfn bc_3_child_block_state() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(7);\r\n\tassert_eq!(b1.state, 7);\r\n}\r\n\r\n#[test]\r\nfn bc_3_child_block_consensus_digest() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(7);\r\n\tassert!(hash(&b1) < THRESHOLD);\r\n}\r\n\r\n#[test]\r\nfn bc_3_verify_genesis_only() {\r\n\tlet g = Header::genesis();\r\n\r\n\tassert!(g.verify_sub_chain(&[]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_verify_three_blocks() {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(5);\r\n\tlet b2 = b1.child(6);\r\n\r\n\tassert_eq!(b2.state, 11);\r\n\tassert!(g.verify_sub_chain(&[b1, b2]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_cant_verify_invalid_parent() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.parent = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_cant_verify_invalid_number() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.height = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_cant_verify_invalid_state() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\tb1.state = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_cant_verify_invalid_pow() {\r\n\tlet g = Header::genesis();\r\n\tlet mut b1 = g.child(5);\r\n\t// It is possible that this test will pass with a false positive because\r\n\t// the PoW difficulty is relatively low.\r\n\tb1.consensus_digest = 10;\r\n\r\n\tassert!(!g.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_even_chain_valid() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\t\t\t\t\t  // It' all about the states, not the extrinsics. So once the state is even\r\n\t\t\t\t\t  // we need to keep it that way. So add evens\r\n\tlet b3 = b2.child(1); // 4\r\n\tlet b4 = b3.child(2); // 6\r\n\r\n\tassert!(g.verify_sub_chain_even(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_even_chain_invalid_first_block_after_fork() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\tlet b3 = b2.child(2); // 5 - invalid\r\n\tlet b4 = b3.child(1); // 6\r\n\r\n\tassert!(!g.verify_sub_chain_even(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_even_chain_invalid_second_block_after_fork() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\tlet b3 = b2.child(1); // 4\r\n\tlet b4 = b3.child(1); // 5 - invalid\r\n\r\n\tassert!(!g.verify_sub_chain_even(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_odd_chain_valid() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\t\t\t\t\t  // It' all about the states, not the extrinsics. So once the state is odd\r\n\t\t\t\t\t  // we need to keep it that way. So add evens\r\n\tlet b3 = b2.child(2); // 5\r\n\tlet b4 = b3.child(2); // 7\r\n\r\n\tassert!(g.verify_sub_chain_odd(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_odd_chain_invalid_first_block_after_fork() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\tlet b3 = b2.child(1); // 4 - invalid\r\n\tlet b4 = b3.child(1); // 5\r\n\r\n\tassert!(!g.verify_sub_chain_odd(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_odd_chain_invalid_second_block_after_fork() {\r\n\tlet g = Header::genesis(); // 0\r\n\tlet b1 = g.child(2); // 2\r\n\tlet b2 = b1.child(1); // 3\r\n\tlet b3 = b2.child(2); // 5\r\n\tlet b4 = b3.child(1); // 6 - invalid\r\n\r\n\tassert!(!g.verify_sub_chain_odd(&[b1, b2, b3, b4]));\r\n}\r\n\r\n#[test]\r\nfn bc_3_verify_forked_chain() {\r\n\tlet (prefix, even, odd) = build_contentious_forked_chain();\r\n\r\n\tlet g = &prefix[0];\r\n\tlet full_even_chain = [&prefix[1..], &even].concat();\r\n\tlet full_odd_chain = [&prefix[1..], &odd].concat();\r\n\r\n\t// Both chains are individually valid according to the original rules.\r\n\tassert!(g.verify_sub_chain(&full_even_chain[..]));\r\n\tassert!(g.verify_sub_chain(&full_odd_chain[..]));\r\n\r\n\t// Only the even chain is valid according to the even rules\r\n\tassert!(g.verify_sub_chain_even(&full_even_chain[..]));\r\n\tassert!(!g.verify_sub_chain_even(&full_odd_chain[..]));\r\n\r\n\t// Only the odd chain is valid according to the odd rules\r\n\tassert!(!g.verify_sub_chain_odd(&full_even_chain[..]));\r\n\tassert!(g.verify_sub_chain_odd(&full_odd_chain[..]));\r\n}\r\n```\r\n\r\n### p4_batched_extrinsic.rs\r\n```\r\n//! Until now, each block has contained just a single extrinsic. Really we would prefer to batch\r\n//! them. Now, we stop relying solely on headers, and instead, create complete blocks.\r\n\r\nuse crate::hash;\r\ntype Hash = u64;\r\n\r\n/// The header no longer contains an extrinsic directly. Rather a vector of extrinsics will be\r\n/// stored in the block body. We are still storing the state in the header for now. This will change\r\n/// in an upcoming lesson as well.\r\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Header {\r\n\tparent: Hash,\r\n\theight: u64,\r\n\t// We now switch from storing an extrinsic directly, to storing an extrinsic root.\r\n\t// This is basically a concise cryptographic commitment to the complete list of extrinsics.\r\n\t// For example, a hash or a Merkle root.\r\n\textrinsics_root: Hash,\r\n\tstate: u64,\r\n\tpub consensus_digest: u64,\r\n}\r\n\r\n// Methods for creating and verifying headers.\r\n//\r\n// With the extrinsics no longer stored in the header, we can no longer do\r\n// \"on-chain\" execution with just headers. That means that this code actually\r\n// gets simpler in many ways. All the old execution logic, plus some new batching\r\n// logic moves to the block level now.\r\nimpl Header {\r\n\t/// Returns a new valid genesis header.\r\n\tpub fn genesis() -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: 0,\r\n\t\t\tparent: Hash::default(),\r\n\t\t\tstate: 0,\r\n\t\t\tconsensus_digest: 0,\r\n\t\t\textrinsics_root: Hash::default(),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Create and return a valid child header.\r\n\t/// Without the extrinsics themselves, we cannot calculate the final state\r\n\t/// so that information is passed in.\r\n\tpub fn child(&self, extrinsics_root: Hash, state: u64) -> Self {\r\n\t\treturn Self {\r\n\t\t\tstate,\r\n\t\t\textrinsics_root,\r\n\t\t\theight: self.height + 1,\r\n\t\t\tparent: hash(self),\r\n\t\t\tconsensus_digest: 0,\r\n\t\t};\r\n\t}\r\n\r\n\t/// Verify a single child header.\r\n\t///\r\n\t/// This is a slightly different interface from the previous units. Rather\r\n\t/// than verify an entire sub-chain, this function checks a single header.\r\n\t/// This is useful because checking the header can now be thought of as a\r\n\t/// subtask of checking an entire block. So it doesn't make sense to check\r\n\t/// the entire header chain at once if the chain may be invalid at the second block.\r\n\tfn verify_child(&self, child: &Header) -> bool {\r\n\t\tif child.height.saturating_sub(self.height) != 1 {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet valid_hash = child.parent == hash(self);\r\n\t\tlet valid_extrinsic = child.state == self.state;\r\n\t\treturn valid_hash && valid_extrinsic;\r\n\t}\r\n\r\n\t/// Verify that all the given headers form a valid chain from this header to the tip.\r\n\t///\r\n\t/// We can now trivially write the old verification function in terms of the new one.\r\n\t/// Extra street cred if you can write it\r\n\t///  - with a loop\r\n\t///  - with head recursion\r\n\t///  - with tail recursion\r\n\tfn verify_sub_chain(&self, chain: &[Header]) -> bool {\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\tlet get_child_header = chain_iter.next();\r\n\t\treturn match get_child_header {\r\n\t\t\tSome(header) => {\r\n\t\t\t\tself.verify_child(header) && header.verify_sub_chain(chain_iter.as_slice())\r\n\t\t\t},\r\n\t\t\tNone => true,\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/// A complete Block is a header and the extrinsics.\r\n#[derive(Default, Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Block {\r\n\tpub(crate) header: Header,\r\n\tpub(crate) body: Vec<u64>,\r\n}\r\n\r\n// Methods for creating and verifying blocks.\r\n//\r\n// These methods are analogous to the methods on the headers. All of the\r\n// transaction execution logic is now handled at the block level because\r\n// the transactions are no longer available at the Header level.\r\nimpl Block {\r\n\tfn execute_extrinsics(extrinsics: &Vec<u64>) -> u64 {\r\n\t\tlet mut state = 0;\r\n\t\tfor extrinsic in extrinsics.iter() {\r\n\t\t\tstate += extrinsic;\r\n\t\t}\r\n\t\treturn state;\r\n\t}\r\n\t/// Returns a new valid genesis block. By convention this block has no extrinsics.\r\n\tpub fn genesis() -> Self {\r\n\t\treturn Self { header: Header::genesis(), body: vec![] };\r\n\t}\r\n\r\n\t/// Create and return a valid child block.\r\n\t/// The extrinsics are batched now, so we need to execute each of them.\r\n\tpub fn child(&self, extrinsics: Vec<u64>) -> Self {\r\n\t\treturn Self {\r\n\t\t\theader: self.header.child(\r\n\t\t\t\thash(&extrinsics),\r\n\t\t\t\tself.header.state + Block::execute_extrinsics(&extrinsics),\r\n\t\t\t),\r\n\t\t\tbody: extrinsics,\r\n\t\t};\r\n\t}\r\n\r\n\t/// Verify that all the given blocks form a valid chain from this block to the tip.\r\n\t///\r\n\t/// We need to verify the headers as well as execute all transactions and check the final state.\r\n\tpub fn verify_sub_chain(&self, chain: &[Block]) -> bool {\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\tlet get_child_block = chain_iter.next();\r\n\r\n\t\treturn match get_child_block {\r\n\t\t\tSome(block) => {\r\n\t\t\t\t// state value of the current block + state value of the child block = final state in block header\r\n\t\t\t\tBlock::execute_extrinsics(&self.body) + Block::execute_extrinsics(&block.body)\r\n\t\t\t\t\t== block.header.state\r\n\t\t\t\t\t&& hash(&block.body) == block.header.extrinsics_root\r\n\t\t\t\t\t&& block.verify_sub_chain(chain_iter.as_slice())\r\n\t\t\t},\r\n\t\t\tNone => true,\r\n\t\t};\r\n\t}\r\n}\r\n\r\n/// Create an invalid child block of the given block. Although the child block is invalid,\r\n/// the header should be valid.\r\n///\r\n/// Now that extrinsics are separate from headers, the logic for checking headers does\r\n/// not include actual transaction execution. That means it is possible for a header to be\r\n/// valid, but the block containing that header to be invalid.\r\n///\r\n/// Notice that you do not need the entire parent block to do this. You only need the header.\r\nfn build_invalid_child_block_with_valid_header(parent: &Header) -> Block {\r\n\tlet child_header = parent.child(hash(&vec![1, 2, 3]), 0);\r\n\tlet child_block = Block { header: child_header, body: vec![] };\r\n\treturn child_block;\r\n}\r\n\r\n#[test]\r\nfn bc_4_genesis_header() {\r\n\tlet g = Header::genesis();\r\n\tassert_eq!(g.height, 0);\r\n\tassert_eq!(g.parent, 0);\r\n\tassert_eq!(g.extrinsics_root, 0);\r\n\tassert_eq!(g.state, 0);\r\n}\r\n\r\n#[test]\r\nfn bc_4_genesis_block() {\r\n\tlet gh = Header::genesis();\r\n\tlet gb = Block::genesis();\r\n\r\n\tassert_eq!(gb.header, gh);\r\n\tassert!(gb.body.is_empty());\r\n}\r\n\r\n#[test]\r\nfn bc_4_child_block_empty() {\r\n\tlet b0 = Block::genesis();\r\n\tlet b1 = b0.child(vec![]);\r\n\r\n\tassert_eq!(b1.header.height, 1);\r\n\tassert_eq!(b1.header.parent, hash(&b0.header));\r\n\tassert_eq!(b1, Block { header: b1.header.clone(), body: vec![] });\r\n}\r\n\r\n#[test]\r\nfn bc_4_child_block() {\r\n\tlet b0 = Block::genesis();\r\n\tlet b1 = b0.child(vec![1, 2, 3, 4, 5]);\r\n\r\n\tassert_eq!(b1.header.height, 1);\r\n\tassert_eq!(b1.header.parent, hash(&b0.header));\r\n\tassert_eq!(b1, Block { header: b1.header.clone(), body: vec![1, 2, 3, 4, 5] });\r\n}\r\n\r\n#[test]\r\nfn bc_4_child_header() {\r\n\tlet g = Header::genesis();\r\n\tlet h1 = g.child(hash(&[1, 2, 3]), 6);\r\n\r\n\tassert_eq!(h1.height, 1);\r\n\tassert_eq!(h1.parent, hash(&g));\r\n\tassert_eq!(h1.extrinsics_root, hash(&[1, 2, 3]));\r\n\tassert_eq!(h1.state, 6);\r\n\r\n\tlet h2 = h1.child(hash(&[10, 20]), 36);\r\n\r\n\tassert_eq!(h2.height, 2);\r\n\tassert_eq!(h2.parent, hash(&h1));\r\n\tassert_eq!(h2.extrinsics_root, hash(&[10, 20]));\r\n\tassert_eq!(h2.state, 36);\r\n}\r\n\r\n#[test]\r\nfn bc_4_verify_three_blocks() {\r\n\tlet g = Block::genesis();\r\n\tlet b1 = g.child(vec![1]);\r\n\tlet b2 = b1.child(vec![2]);\r\n\tlet chain = vec![g.clone(), b1, b2];\r\n\tassert!(g.verify_sub_chain(&chain[1..]));\r\n}\r\n\r\n#[test]\r\nfn bc_4_invalid_header_does_not_check() {\r\n\tlet g = Header::genesis();\r\n\tlet h1 = Header { parent: 0, height: 100, extrinsics_root: 0, state: 100, consensus_digest: 0 };\r\n\r\n\tassert!(!g.verify_child(&h1));\r\n}\r\n\r\n#[test]\r\nfn bc_4_invalid_block_state_does_not_check() {\r\n\tlet b0 = Block::genesis();\r\n\tlet mut b1 = b0.child(vec![1, 2, 3]);\r\n\tb1.body = vec![];\r\n\r\n\tassert!(!b0.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_4_block_with_invalid_header_does_not_check() {\r\n\tlet b0 = Block::genesis();\r\n\tlet mut b1 = b0.child(vec![1, 2, 3]);\r\n\tb1.header = Header::genesis();\r\n\r\n\tassert!(!b0.verify_sub_chain(&[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_4_student_invalid_block_really_is_invalid() {\r\n\tlet gb = Block::genesis();\r\n\tlet gh = &gb.header;\r\n\r\n\tlet b1 = build_invalid_child_block_with_valid_header(gh);\r\n\tlet h1 = &b1.header;\r\n\r\n\t// Make sure that the header is valid according to header rules.\r\n\tassert!(gh.verify_child(h1));\r\n\r\n\t// Make sure that the block is not valid when executed.\r\n\tassert!(!gb.verify_sub_chain(&[b1]));\r\n}\r\n```\r\n\r\n### p5_fork_choice.rs\r\n```rust\r\n//! Forks in the blockchain represent alternative histories of the system.\r\n//! When forks arise in the blockchain, users need a way to decide which chain\r\n//! they will consider best, for now. This is known as a \"fork choice rule\".\r\n//! There are several meaningful notions of \"best\", so we introduce a trait\r\n//! that allows multiple implementations.\r\n//!\r\n//! Since we have nothing to add to the Block or Header data structures in this lesson,\r\n//! we will import them from the previous lesson.\r\n\r\nuse rand::Rng;\r\n\r\nuse super::p4_batched_extrinsics::{Block, Header};\r\nuse crate::hash;\r\n\r\nconst THRESHOLD: u64 = u64::max_value() / 100;\r\n\r\n/// Judge which blockchain is \"best\" when there are multiple candidates. There are several\r\n/// meaningful notions of \"best\" which is why this is a trait instead of just a\r\n/// method.\r\npub trait ForkChoice {\r\n\t/// Compare two chains, and return the \"best\" one.\r\n\t///\r\n\t/// The chains are not assumed to start from the same genesis block, or even a\r\n\t/// genesis block at all. This makes it possible to compare entirely disjoint\r\n\t/// histories. It also makes it possible to compare _only_ the divergent part\r\n\t/// of sibling chains back to the last common ancestor.\r\n\t///\r\n\t/// The chains are assumed to be valid, so it is up to the caller to check\r\n\t/// validity first if they are unsure.\r\n\tfn first_chain_is_better(chain_1: &[Header], chain_2: &[Header]) -> bool;\r\n\r\n\t/// Compare many chains and return the best one.\r\n\t///\r\n\t/// It is always possible to compare several chains if you are able to compare\r\n\t/// two chains. Therefore this method has a provided implementation. However,\r\n\t/// it may be much more performant to write a fork-choice-specific implementation.\r\n\tfn best_chain<'a>(candidate_chains: &[&'a [Header]]) -> &'a [Header] {\r\n\t\ttodo!(\"Exercise 1\")\r\n\t}\r\n}\r\n\r\n/// The \"best\" chain is simply the longest chain.\r\npub struct LongestChainRule;\r\n\r\nimpl ForkChoice for LongestChainRule {\r\n\tfn first_chain_is_better(chain_1: &[Header], chain_2: &[Header]) -> bool {\r\n\t\treturn chain_1.len() > chain_2.len();\r\n\t}\r\n\r\n\tfn best_chain<'a>(candidate_chains: &[&'a [Header]]) -> &'a [Header] {\r\n\t\t// Remember, this method is provided. You _can_ solve the exercise by\r\n\t\t// simply deleting this block. It is up to you to decide whether this fork\r\n\t\t// choice warrants a custom implementation.\r\n\t\tlet mut chain_iter = candidate_chains.iter();\r\n\t\tlet mut best = chain_iter.next().unwrap();\r\n\t\twhile let Some(next_chain) = chain_iter.next() {\r\n\t\t\tif best.len() < next_chain.len() {\r\n\t\t\t\tbest = next_chain;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn best;\r\n\t}\r\n}\r\n\r\n/// The best chain is the one with the most accumulated work.\r\n///\r\n/// In Proof of Work chains, each block contains a certain amount of \"work\".\r\n/// Roughly speaking, the lower a block's hash is, the more work it contains,\r\n/// because finding a block with a low hash requires, on average, trying more\r\n/// nonces. Modeling the amount of work required to achieve a particular hash\r\n/// is out of scope for this exercise, so we will use the not-really-right-but\r\n/// conceptually-good-enough formula `work = THRESHOLD - block_hash`\r\npub struct HeaviestChainRule;\r\n\r\nfn generate_nonce() -> u64 {\r\n\tlet mut rng = rand::thread_rng();\r\n\treturn rng.gen::<u32>() as u64;\r\n}\r\n\r\nfn mine_consensus_digest(header: &mut Header, threshold: u64) {\r\n\tlet mut valid_header = header.clone();\r\n\tloop {\r\n\t\tlet nonce = generate_nonce();\r\n\t\tvalid_header.consensus_digest = nonce;\r\n\t\tif hash(&valid_header) < threshold {\r\n\t\t\theader.consensus_digest = nonce;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n/// Mutates a block (and its embedded header) to contain more PoW difficulty.\r\n/// This will be useful for exploring the heaviest chain rule. The expected\r\n/// usage is that you create a block using the normal `Block.child()` method\r\n/// and then pass the block to this helper for additional mining.\r\nfn mine_extra_hard(block: &mut Block, threshold: u64) {\r\n\tmine_consensus_digest(&mut block.header, threshold);\r\n}\r\n\r\nimpl HeaviestChainRule {\r\n\tfn get_total_work(chain: &[Header]) -> i64 {\r\n\t\tlet mut total_work: i64 = 0;\r\n\t\tchain.iter().for_each(|header| {\r\n\t\t\ttotal_work = total_work.saturating_add(THRESHOLD as i64 - hash(header) as i64);\r\n\t\t});\r\n\t\treturn total_work;\r\n\t}\r\n}\r\n\r\nimpl ForkChoice for HeaviestChainRule {\r\n\tfn first_chain_is_better(chain_1: &[Header], chain_2: &[Header]) -> bool {\r\n\t\treturn HeaviestChainRule::get_total_work(chain_1)\r\n\t\t\t> HeaviestChainRule::get_total_work(chain_2);\r\n\t}\r\n\r\n\tfn best_chain<'a>(candidate_chains: &[&'a [Header]]) -> &'a [Header] {\r\n\t\t// Remember, this method is provided.\r\n\t\tlet mut chain_iter = candidate_chains.iter();\r\n\t\tlet mut best = chain_iter.next().unwrap();\r\n\t\twhile let Some(next_chain) = chain_iter.next() {\r\n\t\t\tif HeaviestChainRule::get_total_work(best)\r\n\t\t\t\t< HeaviestChainRule::get_total_work(next_chain)\r\n\t\t\t{\r\n\t\t\t\tbest = next_chain;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn best;\r\n\t}\r\n}\r\n/// The best chain is the one with the most blocks that have even hashes.\r\n///\r\n/// This exact rule is a bit contrived, but it does model a family of fork choice rules\r\n/// that are useful in the real world. We just can't code them here because we haven't\r\n/// implemented Proof of Authority yet. Consider the following real world examples\r\n/// that have very similar implementations.\r\n///\r\n/// 1. Secondary authors. In each round there is one author who is supposed to author. If that\r\n///    author fails to create a block, there is a secondary author who may do so. The best chain is\r\n///    the one with the most primary-authored blocks.\r\n///\r\n/// 2. Interleaved Pow/PoA. In each round there is one author who is allowed to author. Anyone else\r\n///    is allowed to mine a PoW-style block. The best chain is the one with the most PoA blocks, and\r\n///    ties are broken by the most accumulated work.\r\npub struct MostBlocksWithEvenHash;\r\n\r\nimpl MostBlocksWithEvenHash {\r\n\tpub fn count_even_hash(chain: &[Header]) -> usize {\r\n\t\tlet mut block_count = 0;\r\n\t\tchain.iter().for_each(|block| {\r\n\t\t\tlet block_hash = hash(block);\r\n\t\t\tif block_hash % 2 == 0 {\r\n\t\t\t\tblock_count += 1;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn block_count;\r\n\t}\r\n}\r\n\r\nimpl ForkChoice for MostBlocksWithEvenHash {\r\n\tfn first_chain_is_better(chain_1: &[Header], chain_2: &[Header]) -> bool {\r\n\t\treturn MostBlocksWithEvenHash::count_even_hash(chain_1)\r\n\t\t\t> MostBlocksWithEvenHash::count_even_hash(chain_2);\r\n\t}\r\n\r\n\tfn best_chain<'a>(candidate_chains: &[&'a [Header]]) -> &'a [Header] {\r\n\t\t// Remember, this method is provided.\r\n\t\tlet mut chain_iter = candidate_chains.iter();\r\n\t\tlet mut best = chain_iter.next().unwrap();\r\n\t\twhile let Some(next_chain) = chain_iter.next() {\r\n\t\t\tif MostBlocksWithEvenHash::count_even_hash(best)\r\n\t\t\t\t< MostBlocksWithEvenHash::count_even_hash(next_chain)\r\n\t\t\t{\r\n\t\t\t\tbest = next_chain;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn best;\r\n\t}\r\n}\r\n\r\n// This lesson has omitted one popular fork choice rule:\r\n// GHOST - Greedy Heaviest Observed SubTree\r\n//\r\n// I've omitted GHOST from here because it requires information about blocks that\r\n// are _not_ in the chain to decide which chain is best. Therefore it does't work\r\n// well with this relatively simple trait definition. We will return to the GHOST\r\n// rule later when we have written a full blockchain client\r\n//\r\n// The GHOST rule was first published in 2013 by Yonatan Sompolinsky and Aviv Zohar.\r\n// Learn more at https://eprint.iacr.org/2013/881.pdf\r\n\r\n//\r\n\r\n/// Build and return two different chains with a common prefix.\r\n/// They should have the same genesis header. Both chains should be valid.\r\n/// The first chain should be longer (have more blocks), but the second\r\n/// chain should have more accumulated work.\r\n///\r\n/// Return your solutions as three vectors:\r\n/// 1. The common prefix including genesis\r\n/// 2. The suffix chain which is longer (non-overlapping with the common prefix)\r\n/// 3. The suffix chain with more work (non-overlapping with the common prefix)\r\nfn create_fork_one_side_longer_other_side_heavier() -> (Vec<Header>, Vec<Header>, Vec<Header>) {\r\n\tlet g = Header::genesis();\r\n\tlet b1 = g.child(hash(&vec![1]), 2);\r\n\tlet b2 = b1.child(hash(&vec![2]), 3);\r\n\tlet prefix_chain = vec![b1, b2];\r\n\r\n\t// 1. The common prefix including genesis\r\n\tlet forked_header = prefix_chain.last().unwrap();\r\n\r\n\t// 2. The suffix chain which is longer (non-overlapping with the common prefix)\r\n\tlet mut longest_chain_ha = forked_header.child(hash(&vec![1, 2]), 3);\r\n\tmine_consensus_digest(&mut longest_chain_ha, u64::max_value() / 2);\r\n\tlet mut longest_chain_hb = longest_chain_ha.child(hash(&vec![3, 4]), 10);\r\n\tmine_consensus_digest(&mut longest_chain_hb, u64::max_value() / 5);\r\n\tlet mut longest_chain_hc = longest_chain_hb.child(hash(&vec![7]), 17);\r\n\tmine_consensus_digest(&mut longest_chain_hc, u64::max_value() / 3);\r\n\tlet mut longest_chain_hd = longest_chain_hc.child(hash(&vec![4, 5]), 26);\r\n\tmine_consensus_digest(&mut longest_chain_hd, u64::max_value() / 4);\r\n\r\n\tlet mut more_work_chain_ha = forked_header.child(hash(&vec![5, 6]), 11);\r\n\tmine_consensus_digest(&mut more_work_chain_ha, u64::max_value() / 200); // 1 valid block / 200 blocks\r\n\tlet mut more_work_chain_hb = more_work_chain_ha.child(hash(&vec![1, 2]), 14);\r\n\tmine_consensus_digest(&mut more_work_chain_hb, u64::max_value() / 250); // 1 valid block / 250 blocks\r\n\r\n\treturn (\r\n\t\tprefix_chain.clone(),\r\n\t\tvec![longest_chain_ha, longest_chain_hb, longest_chain_hc, longest_chain_hd],\r\n\t\tvec![more_work_chain_ha, more_work_chain_hb],\r\n\t);\r\n}\r\n\r\n#[test]\r\nfn bc_5_longest_chain() {\r\n\tlet g = Header::genesis();\r\n\r\n\tlet h_a1 = g.child(hash(&[1]), 1);\r\n\tlet h_a2 = h_a1.child(hash(&[2]), 2);\r\n\tlet chain_1 = &[g.clone(), h_a1, h_a2];\r\n\r\n\tlet h_b1 = g.child(hash(&[3]), 3);\r\n\tlet chain_2 = &[g, h_b1];\r\n\r\n\tassert!(LongestChainRule::first_chain_is_better(chain_1, chain_2));\r\n\r\n\tassert_eq!(LongestChainRule::best_chain(&[chain_1, chain_2]), chain_1);\r\n}\r\n\r\n#[test]\r\nfn bc_5_mine_to_custom_difficulty() {\r\n\tlet g = Block::genesis();\r\n\tlet mut b1 = g.child(vec![1, 2, 3]);\r\n\r\n\t// We want the custom threshold to be high enough that we don't take forever mining\r\n\t// but low enough that it is unlikely we accidentally meet it with the normal\r\n\t// block creation function\r\n\tlet custom_threshold = u64::max_value() / 1000;\r\n\tmine_extra_hard(&mut b1, custom_threshold);\r\n\r\n\tassert!(hash(&b1.header) < custom_threshold);\r\n}\r\n\r\n#[test]\r\nfn bc_5_heaviest_chain() {\r\n\tlet g = Header::genesis();\r\n\r\n\tlet mut i = 0;\r\n\tlet h_a1 = loop {\r\n\t\tlet header = g.child(hash(&[i]), i);\r\n\t\t// Extrinsics root hash must be higher than threshold (less work done)\r\n\t\tif hash(&header) > THRESHOLD {\r\n\t\t\tbreak header;\r\n\t\t}\r\n\t\ti += 1;\r\n\t};\r\n\tlet chain_1 = &[g.clone(), h_a1];\r\n\r\n\tlet h_b1 = loop {\r\n\t\tlet header = g.child(hash(&[i]), i);\r\n\t\t// Extrinsics root hash must be lower than threshold (more work done)\r\n\t\tif hash(&header) < THRESHOLD {\r\n\t\t\tbreak header;\r\n\t\t}\r\n\t\ti += 1;\r\n\t};\r\n\tlet chain_2 = &[g, h_b1];\r\n\r\n\tassert!(HeaviestChainRule::first_chain_is_better(chain_2, chain_1));\r\n\r\n\tassert_eq!(HeaviestChainRule::best_chain(&[chain_1, chain_2]), chain_2);\r\n}\r\n\r\n#[test]\r\nfn bc_5_most_even_blocks() {\r\n\tlet g = Header::genesis();\r\n\r\n\tlet mut h_a1 = g.child(2, 0);\r\n\tfor i in 0..u64::max_value() {\r\n\t\th_a1 = g.child(2, i);\r\n\t\tif hash(&h_a1) % 2 == 0 {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tlet mut h_a2 = g.child(2, 0);\r\n\tfor i in 0..u64::max_value() {\r\n\t\th_a2 = h_a1.child(2, i);\r\n\t\tif hash(&h_a2) % 2 == 0 {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tlet chain_1 = &[g.clone(), h_a1, h_a2];\r\n\r\n\tlet mut h_b1 = g.child(2, 0);\r\n\tfor i in 0..u64::max_value() {\r\n\t\th_b1 = g.child(2, i);\r\n\t\tif hash(&h_b1) % 2 != 0 {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tlet mut h_b2 = g.child(2, 0);\r\n\tfor i in 0..u64::max_value() {\r\n\t\th_b2 = h_b1.child(2, i);\r\n\t\tif hash(&h_b2) % 2 != 0 {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tlet chain_2 = &[g, h_b1, h_b2];\r\n\r\n\tassert!(MostBlocksWithEvenHash::first_chain_is_better(chain_1, chain_2));\r\n\r\n\tassert_eq!(MostBlocksWithEvenHash::best_chain(&[chain_1, chain_2]), chain_1);\r\n}\r\n\r\n#[test]\r\nfn bc_5_longest_vs_heaviest() {\r\n\tlet (_, longest_chain, pow_chain) = create_fork_one_side_longer_other_side_heavier();\r\n\r\n\tassert!(LongestChainRule::first_chain_is_better(&longest_chain, &pow_chain));\r\n\r\n\tassert_eq!(LongestChainRule::best_chain(&[&longest_chain, &pow_chain]), &longest_chain);\r\n\r\n\tlet (_, longest_chain, pow_chain) = create_fork_one_side_longer_other_side_heavier();\r\n\r\n\tassert!(HeaviestChainRule::first_chain_is_better(&pow_chain, &longest_chain));\r\n\r\n\tassert_eq!(HeaviestChainRule::best_chain(&[&longest_chain, &pow_chain]), &pow_chain);\r\n}\r\n\r\n```\r\n\r\n### p6_rich_state.rs\r\n```rust\r\n//! In this lesson we expand our simple notion of state, and show how the state is typically not\r\n//! stored in the header, Or indeed anywhere in the block at all.\r\n//!\r\n//! To facilitate this exercise, consider that we want our blockchain to store not only the sum of\r\n//! the extrinsics, but also the product. You can also imagine many other calculations the chain may\r\n//! want to track (min, max, median, mean, etc).\r\n//!\r\n//! As the state data gets large, it is no longer reasonable to store it in the blocks. But if the\r\n//! state isn't in the blocks, then how can we perform the state-related validation checks we\r\n//! previously performed? We use a state root to cryptographically link our heder to a complete\r\n//! state.\r\n//!\r\n//! This notion of state may sound familiar from our previous work on state machines. Indeed this\r\n//! naming coincidence foreshadows a key abstraction that we will make in a coming chapter.\r\n\r\ntype Hash = u64;\r\nuse crate::hash;\r\n\r\n/// In this section we will use sum and product together to be our state. While this is only a\r\n/// doubling of state size remember that in real world blockchains, the state is often really really\r\n/// large.\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct State {\r\n\tsum: u64,\r\n\tproduct: u64,\r\n}\r\n\r\n/// The header no longer contains the state directly, but rather, it contains a hash of\r\n/// the complete state. This hash will allow block verifiers to cryptographically confirm\r\n/// that they got the same state as the author without having a complete copy of the\r\n/// author's state\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Header {\r\n\tparent: Hash,\r\n\theight: u64,\r\n\textrinsics_root: Hash,\r\n\t/// Stores a cryptographic commitment, like a Merkle root or a hash to the complete\r\n\t/// post state.\r\n\tstate_root: Hash,\r\n\tconsensus_digest: u64,\r\n}\r\n\r\n// Methods for creating and verifying headers.\r\n//\r\n// We already moved the execution logic to the block level in the last section.\r\n// So this code is similar to last time. One key addition we are making is that\r\n// genesis blocks can have an initial state, or \"genesis state\" other than the\r\n// default. So we need to commit the initial state root to the genesis header here.\r\nimpl Header {\r\n\t/// Returns a new valid genesis header.\r\n\tfn genesis(genesis_state_root: Hash) -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: 0,\r\n\t\t\tparent: Hash::default(),\r\n\t\t\tstate_root: genesis_state_root,\r\n\t\t\tconsensus_digest: 0,\r\n\t\t\textrinsics_root: Hash::default(),\r\n\t\t};\r\n\t}\r\n\r\n\t/// Create and return a valid child header.\r\n\t///\r\n\t/// The state root is passed in similarly to how the complete state\r\n\t/// was in the previous section.\r\n\tfn child(&self, extrinsics_root: Hash, state_root: Hash) -> Self {\r\n\t\treturn Self {\r\n\t\t\theight: self.height + 1,\r\n\t\t\tparent: hash(self),\r\n\t\t\tstate_root,\r\n\t\t\tconsensus_digest: 0,\r\n\t\t\textrinsics_root,\r\n\t\t};\r\n\t}\r\n\r\n\t/// Verify a single child header.\r\n\tfn verify_child(&self, child: &Header) -> bool {\r\n\t\tchild.height.saturating_sub(self.height) == 1 && child.parent == hash(self)\r\n\t}\r\n\r\n\t/// Verify that all the given headers form a valid chain from this header to the tip.\r\n\tfn verify_sub_chain(&self, chain: &[Header]) -> bool {\r\n\t\tlet get_next_header = chain.iter().next();\r\n\t\treturn get_next_header.is_some()\r\n\t\t\t&& self.verify_child(get_next_header.unwrap())\r\n\t\t\t&& get_next_header.unwrap().verify_sub_chain(chain);\r\n\t}\r\n}\r\n\r\n/// A complete Block is a header and the extrinsics.\r\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\npub struct Block {\r\n\tpub(crate) header: Header,\r\n\tpub(crate) body: Vec<u64>,\r\n}\r\n\r\n/// Methods for creating and verifying blocks.\r\n///\r\n/// We no longer have access to a state simply by having access to a block.\r\n/// Therefore, we need a pre-state explicitly passed for these block methods.\r\n/// In a real blockchain network, the client is typically responsible for\r\n/// storing some likely-to-be-needed states and have them ready for use in\r\n/// such operations.\r\n///\r\n/// These methods also differ from last time because you will need to\r\n/// calculate state roots to pass to the header-level methods.\r\nimpl Block {\r\n\t/// Returns a new valid genesis block. By convention this block has no extrinsics.\r\n\tpub fn genesis(genesis_state: &State) -> Self {\r\n\t\tBlock { header: Header::genesis(hash(genesis_state)), body: vec![] }\r\n\t}\r\n\r\n\t/// Create and return a valid child block.\r\n\tpub fn child(&self, pre_state: &State, extrinsics: Vec<u64>) -> Self {\r\n\t\tlet state = Block::execute_extrinsics(&mut pre_state.clone(), &extrinsics);\r\n\t\tBlock { header: self.header.child(hash(&extrinsics), hash(&state)), body: extrinsics }\r\n\t}\r\n\r\n\tfn execute_extrinsics(pre_state: &mut State, extrinsics: &Vec<u64>) -> State {\r\n\t\tfor extrinsic in extrinsics.iter() {\r\n\t\t\tpre_state.sum += extrinsic;\r\n\t\t\tpre_state.product *= extrinsic;\r\n\t\t}\r\n\t\treturn pre_state.clone();\r\n\t}\r\n\r\n\t/// Verify that all the given blocks form a valid chain from this block to the tip.\r\n\t///\r\n\t/// This time we need to validate the initial block itself by confirming that we\r\n\t/// have been given a valid pre-state. And we still need to verify the headers,\r\n\t/// execute all transactions, and check the final state.\r\n\tpub fn verify_sub_chain(&self, pre_state: &State, chain: &[Block]) -> bool {\r\n\t\tlet mut chain_iter = chain.iter();\r\n\t\tlet get_child_block = chain_iter.next();\r\n\t\tlet state = Block::execute_extrinsics(&mut pre_state.clone(), &self.body);\r\n\t\t// validate the initial block itself by confirming that we have been give a valid pre-state\r\n\t\treturn hash(&state) == self.header.state_root\r\n\t\t\t&& match get_child_block {\r\n\t\t\t\tSome(block) => {\r\n\t\t\t\t\tself.header.verify_child(&block.header)\r\n\t\t\t\t\t// validate that the block extrinsics stored in body match with the header extrinsic root\r\n\t\t\t\t\t&& hash(&block.body) == block.header.extrinsics_root\r\n\t\t\t\t\t&& block.verify_sub_chain(&state, chain_iter.as_slice())\r\n\t\t\t\t},\r\n\t\t\t\tNone => true,\r\n\t\t\t};\r\n\t}\r\n}\r\n\r\n/// Create an invalid child block of the given block. The returned block should have an\r\n/// incorrect state root. Although the child block is invalid, the header should be valid.\r\n///\r\n/// As we saw in the previous section, the logic for checking headers can no longer\r\n/// not include actual transaction execution, making it possible for invalid blocks\r\n/// to still contain valid headers. There are now two ways to accomplish this.\r\n/// 1. Block includes wrong extrinsics that do not match extrinsics root in header (from last time)\r\n/// 2. Block contains invalid state root that does not match the correct post state (new this time)\r\n///\r\n/// As before, you do not need the entire parent block to do this. You only need the header.\r\n/// You do, however, now need a pre-state as you have throughout much of this section.\r\nfn build_invalid_child_block_with_valid_header(parent: &Header, pre_state: &State) -> Block {\r\n\tlet extrinsics = vec![1, 2, 3];\r\n\tBlock {\r\n\t\theader: parent.child(\r\n\t\t\thash(&extrinsics),\r\n\t\t\thash(&Block::execute_extrinsics(&mut pre_state.clone(), &vec![1])),\r\n\t\t),\r\n\t\tbody: extrinsics,\r\n\t}\r\n}\r\n\r\n#[test]\r\nfn bc_6_genesis_header() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet g = Header::genesis(hash(&state));\r\n\tassert_eq!(g.height, 0);\r\n\tassert_eq!(g.parent, 0);\r\n\tassert_eq!(g.extrinsics_root, 0);\r\n\tassert_eq!(g.state_root, hash(&state));\r\n}\r\n\r\n#[test]\r\nfn bc_6_genesis_block() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet gh = Header::genesis(hash(&state));\r\n\tlet gb = Block::genesis(&state);\r\n\r\n\tassert_eq!(gb.header, gh);\r\n\tassert!(gb.body.is_empty());\r\n}\r\n\r\n#[test]\r\nfn bc_6_child_block_empty() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet b0 = Block::genesis(&state);\r\n\tlet b1 = b0.child(&state, vec![]);\r\n\r\n\tassert_eq!(b1.header.height, 1);\r\n\tassert_eq!(b1.header.parent, hash(&b0.header));\r\n\tassert_eq!(b1, Block { header: b1.header.clone(), body: vec![] });\r\n}\r\n\r\n#[test]\r\nfn bc_6_child_block() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet b0 = Block::genesis(&state);\r\n\tlet b1 = b0.child(&state, vec![1, 2, 3, 4, 5]);\r\n\r\n\tassert_eq!(b1.header.height, 1);\r\n\tassert_eq!(b1.header.parent, hash(&b0.header));\r\n\tassert_eq!(b1, Block { header: b1.header.clone(), body: vec![1, 2, 3, 4, 5] });\r\n}\r\n\r\n#[test]\r\nfn bc_6_child_header() {\r\n\tlet state_0 = State { sum: 6, product: 9 };\r\n\tlet g = Header::genesis(hash(&state_0));\r\n\tlet mut extrinsics = vec![1, 2, 3];\r\n\tlet mut state_1 = state_0;\r\n\tfor extrinsic in extrinsics.iter() {\r\n\t\tstate_1.sum += extrinsic;\r\n\t\tstate_1.product *= extrinsic;\r\n\t}\r\n\tlet h1 = g.child(hash(&extrinsics), hash(&state_1));\r\n\r\n\tassert_eq!(h1.height, 1);\r\n\tassert_eq!(h1.parent, hash(&g));\r\n\tassert_eq!(h1.extrinsics_root, hash(&extrinsics));\r\n\tassert_eq!(h1.state_root, hash(&state_1));\r\n\r\n\textrinsics = vec![10, 20];\r\n\tlet mut state_2 = state_1;\r\n\tfor extrinsic in extrinsics.iter() {\r\n\t\tstate_2.sum += extrinsic;\r\n\t\tstate_2.product *= extrinsic;\r\n\t}\r\n\r\n\tlet h2 = h1.child(hash(&extrinsics), hash(&state_2));\r\n\r\n\tassert_eq!(h2.height, 2);\r\n\tassert_eq!(h2.parent, hash(&h1));\r\n\tassert_eq!(h2.extrinsics_root, hash(&extrinsics));\r\n\tassert_eq!(h2.state_root, hash(&state_2));\r\n}\r\n\r\n#[test]\r\nfn bc_6_verify_three_blocks() {\r\n\tlet state_1 = State { sum: 6, product: 9 };\r\n\tlet g = Block::genesis(&state_1);\r\n\tlet b1 = g.child(&state_1, vec![1]);\r\n\tlet state_2 = State { sum: 7, product: 9 };\r\n\tlet b2 = b1.child(&state_2, vec![2]);\r\n\tlet chain = vec![g.clone(), b1, b2];\r\n\tassert!(g.verify_sub_chain(&state_1, &chain[1..]));\r\n}\r\n\r\n#[test]\r\nfn bc_6_invalid_header_doesnt_check() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet g = Header::genesis(hash(&state));\r\n\tlet h1 = Header {\r\n\t\tparent: 0,\r\n\t\theight: 100,\r\n\t\textrinsics_root: 0,\r\n\t\tstate_root: hash(&(State { sum: 0, product: 0 })),\r\n\t\tconsensus_digest: 0,\r\n\t};\r\n\r\n\tassert!(!g.verify_child(&h1));\r\n}\r\n\r\n#[test]\r\nfn bc_6_invalid_block_state_doesnt_check() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet b0 = Block::genesis(&state);\r\n\tlet mut b1 = b0.child(&state, vec![1, 2, 3]);\r\n\tb1.body = vec![];\r\n\r\n\tassert!(!b0.verify_sub_chain(&state, &[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_6_block_with_invalid_header_doesnt_check() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet b0 = Block::genesis(&state);\r\n\tlet mut b1 = b0.child(&state, vec![1, 2, 3]);\r\n\tb1.header = Header::genesis(hash(&state));\r\n\r\n\tassert!(!b0.verify_sub_chain(&state, &[b1]));\r\n}\r\n\r\n#[test]\r\nfn bc_6_student_invalid_block_really_is_invalid() {\r\n\tlet state = State { sum: 6, product: 9 };\r\n\tlet gb = Block::genesis(&state);\r\n\tlet gh = &gb.header;\r\n\r\n\tlet b1 = build_invalid_child_block_with_valid_header(gh, &state);\r\n\tlet h1 = &b1.header;\r\n\r\n\t// Make sure that the header is valid according to header rules.\r\n\tassert!(gh.verify_child(h1));\r\n\r\n\t// Make sure that the block is not valid when executed.\r\n\tassert!(!gb.verify_sub_chain(&state, &[b1]));\r\n}\r\n\r\n```\r\n\r\n## Please read this information first before working on this issue\r\nBefore committing to the tasks in the community, please skim through the guidelines below to grasp the overall idea of how the community works first. It does not take long but I believe it will give you a big picture of the vision and culture of TheLowLevelers.\r\n- TheLowLevelers Contribution Guidelines ü§ù: https://github.com/orgs/lowlevelers/discussions/8 \r\n- TheLowLevelers Community Guidelines üî•: https://github.com/orgs/lowlevelers/discussions/3\r\n- FAQ Who own the community assets?: https://github.com/orgs/lowlevelers/discussions/9\r\n",
              comments: {
                nodes: [],
              },
              author: {
                avatarUrl:
                  'https://avatars.githubusercontent.com/u/56880684?u=fef25258b81539854c0e1ff255afa40b39f11865&v=4',
                login: 'chungquantin',
              },
              assignees: {
                nodes: [
                  {
                    login: 'chungquantin',
                  },
                ],
                pageInfo: {
                  startCursor: 'MQ',
                  endCursor: 'MQ',
                  hasNextPage: false,
                },
                totalCount: 1,
              },
            },
          },
        ],
      },
    },
  },
};
